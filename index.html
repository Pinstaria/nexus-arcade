<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Nexus Arcade – Clean Edition</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* ===== Base / Global ===== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #1d2140, #050617 55%, #000 100%);
      color: #f4f7ff;
      min-height: 100vh;
    }

    .hidden { display: none !important; }
    .muted { color: #9aa0d2; font-size: 0.85rem; }
    .small { font-size: 0.75rem; }

    button {
      border-radius: 999px;
      padding: 6px 12px;
      border: none;
      background: linear-gradient(135deg, #ff5ef7, #4ef0ff);
      color: #050617;
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      cursor: pointer;
    }
    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    input, select {
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid #272b4b;
      background: #050617;
      color: #f4f7ff;
      font-size: 0.8rem;
    }

    .pill {
      border-radius: 999px;
      padding: 4px 10px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(5,6,23,0.9);
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .card {
      background: rgba(5,6,23,0.9);
      border-radius: 18px;
      border: 1px solid rgba(39,43,75,0.9);
      box-shadow: 0 18px 40px rgba(0,0,0,0.7);
    }

    /* ===== Auth ===== */
    #auth-screen {
      min-height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
    }

    .auth-card {
      padding: 20px;
      width: 320px;
    }

    .auth-card h1 {
      font-size: 1.1rem;
      margin-bottom: 4px;
    }

    .tabs {
      display: flex;
      margin: 10px 0;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #272b4b;
    }

    .tab {
      flex: 1;
      padding: 6px 0;
      border: none;
      background: #111325;
      color: #9aa0d2;
      font-size: 0.8rem;
      cursor: pointer;
    }

    .tab.active {
      background: #4ef0ff;
      color: #050617;
      font-weight: 600;
    }

    .form {
      display: none;
      flex-direction: column;
      gap: 8px;
      margin-top: 4px;
    }
    .form.active { display: flex; }

    .auth-error {
      min-height: 14px;
      color: #ff5e7a;
      font-size: 0.75rem;
    }

    /* ===== App Layout ===== */
    #app {
      padding: 10px;
    }

    .app-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
      gap: 8px;
      flex-wrap: wrap;
    }

    .app-header h1 {
      font-size: 1.2rem;
    }

    .header-right {
      display: flex;
      gap: 6px;
      align-items: center;
      flex-wrap: wrap;
    }

    .layout {
      display: grid;
      grid-template-columns: 2fr 1.4fr;
      gap: 10px;
    }

    @media (max-width: 900px) {
      .layout { grid-template-columns: 1fr; }
    }

    /* ===== Left: Games ===== */
    .game-panel {
      padding: 8px;
    }

    .games-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 6px;
      margin-bottom: 6px;
    }

    .game-tile {
      background: linear-gradient(145deg, #101326, #050617);
      border-radius: 14px;
      padding: 8px;
      cursor: pointer;
      border: 1px solid #272b4b;
      font-size: 0.75rem;
      display: grid;
      grid-template-columns: 26px 1fr;
      gap: 6px;
      align-items: center;
      transition: transform 0.08s, box-shadow 0.08s, border-color 0.08s;
    }

    .game-tile:hover {
      transform: translateY(-1px);
      box-shadow: 0 10px 25px rgba(0,0,0,0.5);
    }

    .game-tile.active {
      border-color: #4ef0ff;
      box-shadow: 0 0 12px rgba(78,240,255,0.9);
    }

    .game-icon {
      width: 24px;
      height: 24px;
      border-radius: 8px;
      background: radial-gradient(circle at top, #ff5ef7, #4ef0ff);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.9rem;
      color: #050617;
    }

    .game-tile h3 {
      font-size: 0.8rem;
      margin-bottom: 2px;
    }

    .game-tile p {
      color: #9aa0d2;
      font-size: 0.7rem;
    }

    .game-tags {
      display: flex;
      gap: 3px;
      flex-wrap: wrap;
      margin-top: 2px;
    }

    .game-tag {
      border-radius: 999px;
      border: 1px solid #272b4b;
      padding: 1px 5px;
      font-size: 0.65rem;
      color: #9aa0d2;
    }

    #game-canvas {
      display: block;
      width: 100%;
      border-radius: 12px;
      background: #050617;
      margin-top: 4px;
      border: 1px solid #272b4b;
    }

    #game-help {
      margin-top: 4px;
      font-size: 0.75rem;
      color: #9aa0d2;
    }

    /* ===== Right: Two Tabs ===== */
    .right-panel {
      padding: 8px;
    }

    .right-tabs {
      display: flex;
      gap: 4px;
      border-bottom: 1px solid #272b4b;
      margin-bottom: 4px;
    }

    .right-tab-btn {
      flex: 1;
      padding: 4px 0;
      background: none;
      border: none;
      cursor: pointer;
      color: #9aa0d2;
      font-size: 0.75rem;
      border-radius: 8px 8px 0 0;
    }

    .right-tab-btn.active {
      background: #111325;
      color: #4ef0ff;
      border-bottom: 2px solid #4ef0ff;
    }

    .right-tab {
      display: none;
      margin-top: 4px;
    }

    .right-tab.active {
      display: block;
    }

    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      align-items: center;
      margin: 3px 0;
    }

    .inventory-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      max-height: 140px;
      overflow-y: auto;
      margin-top: 4px;
    }

    .color-card {
      border-radius: 10px;
      border: 1px solid #272b4b;
      padding: 4px;
      width: 86px;
      font-size: 0.7rem;
      cursor: pointer;
      background: #050617;
    }

    .color-card.selected {
      border-color: #4ef0ff;
      box-shadow: 0 0 8px rgba(78,240,255,0.8);
    }

    .color-swatch {
      height: 18px;
      border-radius: 6px;
      margin-bottom: 2px;
    }

    .rarity-badge {
      display: inline-block;
      padding: 0 5px;
      border-radius: 999px;
      font-size: 0.65rem;
      border: 1px solid;
      margin-top: 1px;
    }

    /* Rarity colors */
    .rarity-Common { border-color:#616161; color:#bdbdbd; }
    .rarity-Uncommon { border-color:#43a047; color:#a5d6a7; }
    .rarity-Rare { border-color:#1e88e5; color:#90caf9; }
    .rarity-Epic { border-color:#8e24aa; color:#e1bee7; }
    .rarity-Legendary { border-color:#ffb300; color:#ffecb3; }
    .rarity-Mythical { border-color:#ec407a; color:#f8bbd0; }
    .rarity-Exotic { border-color:#00bfa5; color:#b2dfdb; }
    .rarity-Celestial { border-color:#5c6bc0; color:#c5cae9; }
    .rarity-Godly { border-color:#f4511e; color:#ffccbc; }
    .rarity-Impossible { border-color:#9e9d24; color:#e6ee9c; }
    .rarity-Zenith { border-color:#ff6f00; color:#ffe082; }
    .rarity-Singularity { border-color:#546e7a; color:#cfd8dc; }
    .rarity-Paradox { border-color:#ab47bc; color:#e1bee7; }
    .rarity-Omniversal { border-color:#26c6da; color:#b2ebf2; }

    .list-box,
    .recipes-list,
    .leaderboard,
    .index-box {
      max-height: 120px;
      overflow-y: auto;
      border-radius: 10px;
      border: 1px solid #272b4b;
      padding: 4px;
      font-size: 0.7rem;
      background: #050617;
    }

    .lb-entry {
      display: flex;
      justify-content: space-between;
      margin-bottom: 2px;
    }

    .index-entry {
      margin-bottom: 2px;
    }

    .profile-stat {
      display: flex;
      justify-content: space-between;
      margin-bottom: 2px;
      font-size: 0.75rem;
    }
  </style>
</head>
<body>
  <!-- AUTH SCREEN -->
  <div id="auth-screen">
    <div class="card auth-card">
      <h1>Nexus Arcade</h1>
      <p class="muted small">Single-file edition · everything saved in this browser</p>

      <div class="tabs">
        <button class="tab active" data-tab="login">Login</button>
        <button class="tab" data-tab="register">Register</button>
      </div>

      <form id="login-form" class="form active">
        <input type="text" name="username" placeholder="Username" required />
        <input type="password" name="password" placeholder="Password" required />
        <button type="submit">Login</button>
        <div id="login-error" class="auth-error"></div>
      </form>

      <form id="register-form" class="form">
        <input type="text" name="username" placeholder="Username" required />
        <input type="password" name="password" placeholder="Password" required />
        <button type="submit">Register</button>
        <div id="register-error" class="auth-error"></div>
      </form>

      <p class="muted small" style="margin-top:6px;">
        You can make multiple users & test different paths. No server, no backend, just this file.
      </p>
    </div>
  </div>

  <!-- APP -->
  <div id="app" class="hidden">
    <header class="app-header">
      <div>
        <h1>Nexus Arcade</h1>
        <div id="welcome" class="muted small"></div>
      </div>
      <div class="header-right">
        <span id="weather-pill" class="pill">Weather: Clear</span>
        <span id="currency-pill" class="pill">Credits: 0</span>
        <button id="logout-btn">Logout</button>
      </div>
    </header>

    <main class="layout">
      <!-- LEFT: GAMES -->
      <section class="card game-panel">
        <div class="muted small" style="margin-bottom:4px;">1. Choose a game  ·  2. Read the short help under the canvas  ·  3. Play</div>
        <div class="games-grid">
          <button class="game-tile" data-game="packian">
            <div class="game-icon">P</div>
            <div>
              <h3>Packian</h3>
              <p>Packs, rarities, mutations, crafting, collecting.</p>
              <div class="game-tags">
                <span class="game-tag">Core</span>
                <span class="game-tag">Economy</span>
              </div>
            </div>
          </button>

          <button class="game-tile" data-game="emberforge">
            <div class="game-icon">E</div>
            <div>
              <h3>Emberforge</h3>
              <p>Space = fuel. Collapse when stability hits 0.</p>
              <div class="game-tags">
                <span class="game-tag">Risk</span>
              </div>
            </div>
          </button>

          <button class="game-tile" data-game="bloomcraft">
            <div class="game-icon">B</div>
            <div>
              <h3>Bloomcraft</h3>
              <p>Blooms grow & mutate based on weather.</p>
              <div class="game-tags">
                <span class="game-tag">Idle</span>
              </div>
            </div>
          </button>

          <button class="game-tile" data-game="voltline">
            <div class="game-icon">V</div>
            <div>
              <h3>Voltline</h3>
              <p>Click nodes. Longer chain = better score.</p>
              <div class="game-tags">
                <span class="game-tag">Chain</span>
              </div>
            </div>
          </button>

          <button class="game-tile" data-game="cryoshift">
            <div class="game-icon">C</div>
            <div>
              <h3>Cryoshift</h3>
              <p>Space = Freeze/Thaw. Don’t shatter.</p>
              <div class="game-tags">
                <span class="game-tag">Balance</span>
              </div>
            </div>
          </button>

          <button class="game-tile" data-game="riftweave">
            <div class="game-icon">R</div>
            <div>
              <h3>Riftweave</h3>
              <p>Click to add threads & tension.</p>
              <div class="game-tags">
                <span class="game-tag">Score</span>
              </div>
            </div>
          </button>

          <button class="game-tile" data-game="phaseRunner">
            <div class="game-icon">↕</div>
            <div>
              <h3>Phase Runner</h3>
              <p>W/S or ↑/↓ to change lane & dodge.</p>
              <div class="game-tags">
                <span class="game-tag">Reflex</span>
              </div>
            </div>
          </button>

          <button class="game-tile" data-game="precisionPulse">
            <div class="game-icon">◎</div>
            <div>
              <h3>Precision Pulse</h3>
              <p>Space near center = high accuracy.</p>
              <div class="game-tags">
                <span class="game-tag">Timing</span>
              </div>
            </div>
          </button>

          <button class="game-tile" data-game="shardTowers">
            <div class="game-icon">▲</div>
            <div>
              <h3>Shard Towers</h3>
              <p>Buy towers, they earn shards per tick.</p>
              <div class="game-tags">
                <span class="game-tag">Idle</span>
                <span class="game-tag">Upgrades</span>
              </div>
            </div>
          </button>
        </div>

        <canvas id="game-canvas" width="480" height="270"></canvas>
        <div id="game-help" class="muted small">
          Select a game above to see its controls and goal here.
        </div>
      </section>

      <!-- RIGHT: PACKIAN + ARCADE INFO -->
      <section class="card right-panel">
        <div class="right-tabs">
          <button class="right-tab-btn active" data-rtab="tab-packian">Packian</button>
          <button class="right-tab-btn" data-rtab="tab-arcade">Arcade & Scores</button>
        </div>

        <!-- PACKIAN TAB -->
        <div id="tab-packian" class="right-tab active">
          <p class="muted small">
            Packian basics: Open packs ▸ get colors ▸ select some ▸ mutate or sell ▸ fill your Packidex.
          </p>

          <div class="row" style="margin-top:4px;">
            <span class="muted small">Weather: <strong id="weather-label">Clear</strong></span>
            <span class="muted small">Index entries: <strong id="index-count">0</strong></span>
          </div>

          <div class="row">
            <button id="btn-open-pack">Open Pack (20)</button>
            <button id="btn-mutate">Mutate Selected</button>
            <button id="btn-sell">Sell Selected</button>
          </div>

          <div id="inventory" class="inventory-grid"></div>

          <p class="muted small" style="margin-top:4px;">Craft recipes from selected items:</p>
          <div class="row">
            <input id="recipe-name" type="text" placeholder="Recipe name" />
            <select id="recipe-visibility">
              <option value="private">Private</option>
              <option value="public">Public</option>
            </select>
            <button id="btn-save-recipe">Save recipe</button>
          </div>

          <p class="muted small" style="margin-top:4px;">Your recipes:</p>
          <div id="recipes" class="recipes-list"></div>

          <p class="muted small" style="margin-top:4px;">Packidex (discovered color+rarity combos):</p>
          <div id="index-box" class="index-box"></div>
        </div>

        <!-- ARCADE & SCORES TAB -->
        <div id="tab-arcade" class="right-tab">
          <h3 class="small">Your snapshot</h3>
          <div id="profile-stats"></div>

          <h3 class="small" style="margin-top:6px;">Recent scores (this user)</h3>
          <div id="recent-scores" class="list-box"></div>

          <h3 class="small" style="margin-top:6px;">Leaderboards (local only)</h3>
          <div class="row">
            <select id="lb-game-select">
              <option value="packian">Packian value streak</option>
              <option value="emberforge">Emberforge heat</option>
              <option value="bloomcraft">Bloomcraft mutation</option>
              <option value="voltline">Voltline chain</option>
              <option value="cryoshift">Cryoshift stability</option>
              <option value="riftweave">Riftweave score</option>
              <option value="phaseRunner">Phase Runner distance</option>
              <option value="precisionPulse">Precision Pulse accuracy</option>
              <option value="shardTowers">Shard Towers shards</option>
            </select>
            <button id="lb-refresh">Show</button>
          </div>
          <div id="leaderboard" class="leaderboard"></div>

          <h3 class="small" style="margin-top:6px;">Event log</h3>
          <div id="log-box" class="list-box small muted">
            Welcome to Nexus Arcade. Everything you do is logged here.
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    /* ==========================
       Basic state & helpers
       ========================== */
    const STORAGE_KEY = "nexusArcade_clean_v1";

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return { users: {}, currentUser: null, leaderboards: {}, publicRecipes: [] };
        return JSON.parse(raw);
      } catch {
        return { users: {}, currentUser: null, leaderboards: {}, publicRecipes: [] };
      }
    }

    function saveState() {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
    }

    let state = loadState();

    function log(msg) {
      const box = document.getElementById("log-box");
      if (!box) return;
      const time = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
      box.innerHTML = `[${time}] ${msg}<br>` + box.innerHTML;
    }

    /* ==========================
       Auth
       ========================== */
    const authScreen = document.getElementById("auth-screen");
    const app = document.getElementById("app");
    const welcomeEl = document.getElementById("welcome");
    const currencyPill = document.getElementById("currency-pill");
    const weatherPill = document.getElementById("weather-pill");

    const loginForm = document.getElementById("login-form");
    const registerForm = document.getElementById("register-form");
    const loginError = document.getElementById("login-error");
    const registerError = document.getElementById("register-error");

    document.querySelectorAll(".tab").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll(".tab").forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        const t = btn.dataset.tab;
        document.querySelectorAll(".form").forEach(f => f.classList.remove("active"));
        document.getElementById(t + "-form").classList.add("active");
      });
    });

    function hash(pw) {
      let h = 0;
      for (let i = 0; i < pw.length; i++) h = (h * 31 + pw.charCodeAt(i)) >>> 0;
      return h.toString(16);
    }

    function ensureUser(username) {
      if (!state.users[username]) {
        state.users[username] = {
          username,
          passwordHash: null,
          currency: 250,
          inventory: [],
          recipes: [],
          packIndex: {},
          lastScores: {
            packian: null,
            emberforge: null,
            bloomcraft: null,
            voltline: null,
            cryoshift: null,
            riftweave: null,
            phaseRunner: null,
            precisionPulse: null,
            shardTowers: null
          }
        };
      }
      return state.users[username];
    }

    function getUser() {
      if (!state.currentUser) return null;
      return ensureUser(state.currentUser);
    }

    function setCurrentUser(username) {
      state.currentUser = username;
      saveState();
      const u = ensureUser(username);
      authScreen.classList.add("hidden");
      app.classList.remove("hidden");
      welcomeEl.textContent = `Logged in as ${u.username}`;
      updateCurrency();
      refreshPackianUI();
      refreshIndexBox();
      refreshProfilePanel();
      refreshRecentScores();
      log(`Logged in as ${u.username}.`);
      startGame("packian");
    }

    loginForm.addEventListener("submit", e => {
      e.preventDefault();
      loginError.textContent = "";
      const fd = new FormData(loginForm);
      const username = fd.get("username").trim();
      const password = fd.get("password");
      if (!username || !password) {
        loginError.textContent = "Enter username and password.";
        return;
      }
      const u = state.users[username];
      if (!u || !u.passwordHash || u.passwordHash !== hash(password)) {
        loginError.textContent = "Invalid credentials.";
        return;
      }
      setCurrentUser(username);
    });

    registerForm.addEventListener("submit", e => {
      e.preventDefault();
      registerError.textContent = "";
      const fd = new FormData(registerForm);
      const username = fd.get("username").trim();
      const password = fd.get("password");
      if (!username || !password) {
        registerError.textContent = "Enter username and password.";
        return;
      }
      if (state.users[username]) {
        registerError.textContent = "Username already exists.";
        return;
      }
      const u = ensureUser(username);
      u.passwordHash = hash(password);
      saveState();
      setCurrentUser(username);
    });

    document.getElementById("logout-btn").addEventListener("click", () => {
      state.currentUser = null;
      saveState();
      app.classList.add("hidden");
      authScreen.classList.remove("hidden");
      log("Logged out.");
    });

    function updateCurrency() {
      const u = getUser();
      currencyPill.textContent = `Credits: ${u ? u.currency : 0}`;
    }

    // Auto-login if last user exists
    if (state.currentUser && state.users[state.currentUser]) {
      setCurrentUser(state.currentUser);
    }

    /* ==========================
       Right tabs (Packian / Arcade)
       ========================== */
    document.querySelectorAll(".right-tab-btn").forEach(btn => {
      btn.addEventListener("click", () => {
        document.querySelectorAll(".right-tab-btn").forEach(b => b.classList.remove("active"));
        document.querySelectorAll(".right-tab").forEach(p => p.classList.remove("active"));
        btn.classList.add("active");
        document.getElementById(btn.dataset.rtab).classList.add("active");
      });
    });

    /* ==========================
       Game engine
       ========================== */
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");
    const gameHelp = document.getElementById("game-help");
    const gameTiles = document.querySelectorAll(".game-tile");

    let currentGame = null;
    let loopHandle = null;
    let lastTime = 0;

    function startGame(gameId) {
      gameTiles.forEach(t => t.classList.remove("active"));
      const tile = document.querySelector(`.game-tile[data-game="${gameId}"]`);
      if (tile) tile.classList.add("active");

      if (loopHandle) cancelAnimationFrame(loopHandle);
      currentGame = null;

      const helpText = {
        packian: "Packian: Click 'Open Pack', then click items to select them. Use 'Mutate' or 'Sell'. Index fills as you discover combos.",
        emberforge: "Emberforge: Press Space to feed the forge. More heat is good, but if Stability hits 0, the run ends.",
        bloomcraft: "Bloomcraft: Blooms grow & mutate automatically over time. Just watch and see how the weather affects them.",
        voltline: "Voltline: Click nodes to charge them. Each successful click extends the chain, but too much charge overloads.",
        cryoshift: "Cryoshift: Press Space to toggle Frozen/Thawing. Frozen grows value fast but loses stability.",
        riftweave: "Riftweave: Click the canvas to add threads and tension. Too much tension and the weave collapses.",
        phaseRunner: "Phase Runner: Use W/S or Up/Down to change lanes and dodge red blocks. Distance = score.",
        precisionPulse: "Precision Pulse: Press Space as close as possible to the center marker. Smaller time error = higher accuracy.",
        shardTowers: "Shard Towers: Use your credits to buy towers. Each tower type generates shards every few seconds."
      };
      gameHelp.textContent = helpText[gameId] || "Select a game to see its goal and controls.";

      if (gameId === "packian") currentGame = createPackianVisualizer();
      else if (gameId === "emberforge") currentGame = createEmberforge();
      else if (gameId === "bloomcraft") currentGame = createBloomcraft();
      else if (gameId === "voltline") currentGame = createVoltline();
      else if (gameId === "cryoshift") currentGame = createCryoshift();
      else if (gameId === "riftweave") currentGame = createRiftweave();
      else if (gameId === "phaseRunner") currentGame = createPhaseRunner();
      else if (gameId === "precisionPulse") currentGame = createPrecisionPulse();
      else if (gameId === "shardTowers") currentGame = createShardTowers();

      lastTime = performance.now();
      function loop(ts) {
        const dt = ts - lastTime;
        lastTime = ts;
        if (currentGame && currentGame.update) currentGame.update(dt);
        if (currentGame && currentGame.render) currentGame.render();
        loopHandle = requestAnimationFrame(loop);
      }
      loopHandle = requestAnimationFrame(loop);
    }

    gameTiles.forEach(tile => {
      tile.addEventListener("click", () => startGame(tile.dataset.game));
    });

    /* ==========================
       Leaderboards & profile
       ========================== */
    const lbSelect = document.getElementById("lb-game-select");
    const lbRefresh = document.getElementById("lb-refresh");
    const lbBox = document.getElementById("leaderboard");
    const recentScoresBox = document.getElementById("recent-scores");

    function submitScore(gameId, score) {
      const u = getUser();
      if (!u) return;
      if (!state.leaderboards[gameId]) state.leaderboards[gameId] = [];
      const list = state.leaderboards[gameId];
      list.push({ username: u.username, score, ts: Date.now() });
      list.sort((a, b) => b.score - a.score);
      if (list.length > 20) list.length = 20;
      saveState();
      u.lastScores[gameId] = score;
      saveState();
      refreshProfilePanel();
      refreshRecentScores();
    }

    function renderLeaderboard(gameId) {
      const list = state.leaderboards[gameId] || [];
      lbBox.innerHTML = "";
      if (!list.length) {
        lbBox.textContent = "No scores yet.";
        return;
      }
      list.forEach((entry, i) => {
        const div = document.createElement("div");
        div.className = "lb-entry";
        const date = new Date(entry.ts).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
        div.innerHTML = `<span>${i + 1}. ${entry.username}</span><span>${entry.score} <span class="muted small">(${date})</span></span>`;
        lbBox.appendChild(div);
      });
    }

    lbRefresh.addEventListener("click", () => renderLeaderboard(lbSelect.value));

    function refreshProfilePanel() {
      const u = getUser();
      const box = document.getElementById("profile-stats");
      if (!u) {
        box.innerHTML = "";
        return;
      }
      const totalItems = u.inventory.length;
      const distinctIndex = Object.keys(u.packIndex).length;
      const gamesPlayed = Object.values(u.lastScores).filter(v => v !== null).length;
      box.innerHTML = `
        <div class="profile-stat"><span>Total credits</span><span>${u.currency}</span></div>
        <div class="profile-stat"><span>Items owned</span><span>${totalItems}</span></div>
        <div class="profile-stat"><span>Packidex entries</span><span>${distinctIndex}</span></div>
        <div class="profile-stat"><span>Games with scores</span><span>${gamesPlayed}</span></div>
      `;
    }

    function refreshRecentScores() {
      const u = getUser();
      if (!u) return;
      const ls = u.lastScores;
      const labels = {
        packian: "Packian",
        emberforge: "Emberforge",
        bloomcraft: "Bloomcraft",
        voltline: "Voltline",
        cryoshift: "Cryoshift",
        riftweave: "Riftweave",
        phaseRunner: "Phase Runner",
        precisionPulse: "Precision Pulse",
        shardTowers: "Shard Towers"
      };
      recentScoresBox.innerHTML = "";
      Object.keys(ls).forEach(gameId => {
        if (ls[gameId] !== null) {
          const div = document.createElement("div");
          div.textContent = `${labels[gameId]}: ${ls[gameId]}`;
          recentScoresBox.appendChild(div);
        }
      });
      if (!recentScoresBox.innerHTML) {
        recentScoresBox.textContent = "Play any game to see scores here.";
      }
    }

    /* ==========================
       Packian data & UI
       ========================== */
    const rarities = [
      { name: "Common", weight: 55, mult: 1 },
      { name: "Uncommon", weight: 20, mult: 1.5 },
      { name: "Rare", weight: 10, mult: 2 },
      { name: "Epic", weight: 6, mult: 3 },
      { name: "Legendary", weight: 4, mult: 5 },
      { name: "Mythical", weight: 2, mult: 8 },
      { name: "Exotic", weight: 1, mult: 12 },
      { name: "Celestial", weight: 0.5, mult: 18 },
      { name: "Godly", weight: 0.2, mult: 25 },
      { name: "Impossible", weight: 0.05, mult: 40 },
      { name: "Zenith", weight: 0.01, mult: 100 },
      { name: "Singularity", weight: 0.005, mult: 200 },
      { name: "Paradox", weight: 0.001, mult: 500 },
      { name: "Omniversal", weight: 0.0005, mult: 1000 }
    ];

    const baseColors = [
      { id: "crimson", hex: "#ff1744", basePrice: 30 },
      { id: "azure", hex: "#2979ff", basePrice: 30 },
      { id: "emerald", hex: "#00e676", basePrice: 35 },
      { id: "violet", hex: "#d500f9", basePrice: 40 },
      { id: "amber", hex: "#ffca28", basePrice: 25 },
      { id: "obsidian", hex: "#000000", basePrice: 70 },
      { id: "ghost", hex: "#f5f5f5", basePrice: 50 },
      { id: "coral", hex: "#ff7f50", basePrice: 28 },
      { id: "mint", hex: "#98ff98", basePrice: 26 },
      { id: "indigo", hex: "#3f51b5", basePrice: 32 },
      { id: "teal", hex: "#00897b", basePrice: 34 },
      { id: "rose", hex: "#ff4081", basePrice: 31 }
    ];

    const weathers = ["Clear", "Stormy", "Solar", "Void", "Aurora", "Nebula"];
    let weatherIndex = 0;
    let weatherTimer = 0;

    function getCurrentWeather() {
      return weathers[weatherIndex];
    }

    function mutateChance(weather) {
      switch (weather) {
        case "Clear": return 0.05;
        case "Stormy": return 0.15;
        case "Solar": return 0.25;
        case "Void": return 0.4;
        case "Aurora": return 0.3;
        case "Nebula": return 0.5;
        default: return 0.1;
      }
    }

    function randomRarity() {
      const totalWeight = rarities.reduce((s, r) => s + r.weight, 0);
      let roll = Math.random() * totalWeight;
      for (const r of rarities) {
        if (roll < r.weight) return r;
        roll -= r.weight;
      }
      return rarities[0];
    }

    function generateColorToken(ownerName) {
      const bc = baseColors[Math.floor(Math.random() * baseColors.length)];
      const r = randomRarity();
      const id = `${bc.id}-${r.name}-${Math.random().toString(16).slice(2, 8)}`;
      const value = Math.round(bc.basePrice * r.mult);
      return {
        id,
        baseId: bc.id,
        rarity: r.name,
        hex: bc.hex,
        value,
        mutated: false,
        owner: ownerName,
        createdAt: Date.now()
      };
    }

    function mutateColorToken(token, weather) {
      const chance = mutateChance(weather);
      if (Math.random() <= chance) {
        token.mutated = true;
        token.value = Math.round(token.value * (1.5 + Math.random() * 1.5));
        return true;
      }
      return false;
    }

    const weatherLabel = document.getElementById("weather-label");
    const indexCountEl = document.getElementById("index-count");
    const inventoryEl = document.getElementById("inventory");
    const indexBoxEl = document.getElementById("index-box");
    const btnOpenPack = document.getElementById("btn-open-pack");
    const btnMutate = document.getElementById("btn-mutate");
    const btnSell = document.getElementById("btn-sell");
    const recipeNameInput = document.getElementById("recipe-name");
    const recipeVisSelect = document.getElementById("recipe-visibility");
    const btnSaveRecipe = document.getElementById("btn-save-recipe");
    const recipesEl = document.getElementById("recipes");

    let selectedIds = new Set();

    function refreshPackianUI() {
      const u = getUser();
      if (!u) return;
      const w = getCurrentWeather();
      weatherLabel.textContent = w;
      weatherPill.textContent = `Weather: ${w}`;
      indexCountEl.textContent = Object.keys(u.packIndex).length;

      inventoryEl.innerHTML = "";
      for (const token of u.inventory) {
        const div = document.createElement("div");
        div.className = "color-card";
        if (selectedIds.has(token.id)) div.classList.add("selected");
        const rarityClass = "rarity-" + token.rarity.replace(/\s/g, "");
        div.innerHTML = `
          <div class="color-swatch" style="background:${token.hex}"></div>
          <div>${token.baseId}</div>
          <div><span class="rarity-badge ${rarityClass}">${token.rarity}${token.mutated ? "*" : ""}</span></div>
          <div>${token.value}</div>
        `;
        div.addEventListener("click", () => {
          if (selectedIds.has(token.id)) selectedIds.delete(token.id);
          else selectedIds.add(token.id);
          refreshPackianUI();
        });
        inventoryEl.appendChild(div);
      }

      recipesEl.innerHTML = "";
      for (const r of u.recipes) {
        const div = document.createElement("div");
        div.textContent = `${r.name} [${r.visibility}] – ${r.components.join(", ")}`;
        recipesEl.appendChild(div);
      }

      updateCurrency();
    }

    function refreshIndexBox() {
      const u = getUser();
      if (!u) return;
      indexBoxEl.innerHTML = "";
      const keys = Object.keys(u.packIndex).sort();
      if (!keys.length) {
        indexBoxEl.textContent = "No entries yet. Open packs to discover colors.";
        return;
      }
      keys.forEach(key => {
        const entry = u.packIndex[key];
        const rarityClass = "rarity-" + entry.rarity.replace(/\s/g, "");
        const div = document.createElement("div");
        div.className = "index-entry";
        div.innerHTML = `
          <span>${entry.baseId}</span>
          <span class="rarity-badge ${rarityClass}">${entry.rarity}</span>
          <span class="muted small">x${entry.discovered}</span>
        `;
        indexBoxEl.appendChild(div);
      });
    }

    btnOpenPack.addEventListener("click", () => {
      const u = getUser();
      if (!u) return;
      const cost = 20;
      if (u.currency < cost) {
        log("Not enough credits to open a pack.");
        return;
      }
      u.currency -= cost;
      const packSize = 4;
      const newTokens = [];
      for (let i = 0; i < packSize; i++) {
        const t = generateColorToken(u.username);
        newTokens.push(t);
        u.inventory.push(t);
        updatePackIndex(u, t);
      }
      log(`Opened a pack and obtained ${packSize} colors.`);
      selectedIds.clear();
      saveState();
      refreshPackianUI();
      refreshIndexBox();
      const value = newTokens.reduce((s, t) => s + t.value, 0);
      submitScore("packian", value);
    });

    btnMutate.addEventListener("click", () => {
      const u = getUser();
      if (!u) return;
      const ids = Array.from(selectedIds);
      if (!ids.length) {
        log("Select colors to mutate.");
        return;
      }
      const weather = getCurrentWeather();
      let hits = 0;
      for (const id of ids) {
        const token = u.inventory.find(t => t.id === id);
        if (!token) continue;
        if (mutateColorToken(token, weather)) hits++;
        updatePackIndex(u, token);
      }
      log(`Mutated ${ids.length} colors under ${weather}. Successful mutations: ${hits}.`);
      saveState();
      refreshPackianUI();
      refreshIndexBox();
    });

    btnSell.addEventListener("click", () => {
      const u = getUser();
      if (!u) return;
      const ids = Array.from(selectedIds);
      if (!ids.length) {
        log("Select colors to sell.");
        return;
      }
      let gain = 0;
      u.inventory = u.inventory.filter(token => {
        if (ids.includes(token.id)) {
          gain += token.value;
          return false;
        }
        return true;
      });
      u.currency += gain;
      log(`Sold ${ids.length} colors for ${gain} credits.`);
      selectedIds.clear();
      saveState();
      refreshPackianUI();
      refreshIndexBox();
      submitScore("packian", gain);
    });

    function updatePackIndex(user, token) {
      const key = `${token.baseId}:${token.rarity}`;
      if (!user.packIndex[key]) {
        user.packIndex[key] = {
          baseId: token.baseId,
          rarity: token.rarity,
          discovered: 0,
          firstAt: Date.now()
        };
      }
      user.packIndex[key].discovered++;
    }

    btnSaveRecipe.addEventListener("click", () => {
      const u = getUser();
      if (!u) return;
      const ids = Array.from(selectedIds);
      if (ids.length < 2) {
        log("Select at least 2 colors to define a recipe.");
        return;
      }
      const name = recipeNameInput.value.trim() || "Untitled";
      const vis = recipeVisSelect.value;
      const components = ids
        .map(id => u.inventory.find(t => t.id === id))
        .filter(Boolean)
        .map(t => t.baseId);
      const recipe = {
        id: "r-" + Math.random().toString(16).slice(2, 8),
        name,
        components,
        visibility: vis
      };
      u.recipes.push(recipe);
      if (vis === "public") {
        state.publicRecipes.push({ creator: u.username, name, components });
      }
      log(`Saved recipe "${name}" (${vis}).`);
      saveState();
      refreshPackianUI();
    });

    /* ==========================
       Packian visualizer
       ========================== */
    function createPackianVisualizer() {
      const particles = [];
      for (let i = 0; i < 60; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 0.06,
          vy: (Math.random() - 0.5) * 0.06,
          r: 2 + Math.random() * 4,
          color: `hsl(${Math.random() * 360},80%,60%)`
        });
      }
      return {
        update(dt) {
          weatherTimer += dt;
          if (weatherTimer > 12000) {
            weatherTimer = 0;
            weatherIndex = (weatherIndex + 1) % weathers.length;
            refreshPackianUI();
            log(`Weather shifted to ${getCurrentWeather()}.`);
          }
          for (const p of particles) {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            if (p.x < 0) p.x += canvas.width;
            if (p.x > canvas.width) p.x -= canvas.width;
            if (p.y < 0) p.y += canvas.height;
            if (p.y > canvas.height) p.y -= canvas.height;
          }
        },
        render() {
          ctx.fillStyle = "#050617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          for (const p of particles) {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      };
    }

    /* ==========================
       Emberforge
       ========================== */
    function createEmberforge() {
      let heat = 0;
      let stability = 100;
      let running = true;
      let lastSpace = 0;

      function keyHandler(e) {
        if (!running) return;
        if (e.code === "Space" && Date.now() - lastSpace > 150) {
          lastSpace = Date.now();
          heat += 10 + Math.random() * 10;
          stability -= 5 + Math.random() * 3;
          if (stability <= 0) {
            stability = 0;
            running = false;
            const score = Math.round(heat);
            log(`Emberforge collapsed at ${score} heat.`);
            submitScore("emberforge", score);
          }
        }
      }
      window.addEventListener("keydown", keyHandler);

      return {
        update(dt) {
          if (!running) return;
          heat += dt * 0.003;
          stability -= dt * 0.002;
          if (stability <= 0) {
            stability = 0;
            running = false;
            const score = Math.round(heat);
            log(`Emberforge collapsed at ${score} heat.`);
            submitScore("emberforge", score);
          }
        },
        render() {
          ctx.fillStyle = "#050617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          const heatNorm = Math.min(1, heat / 500);
          const color = `hsl(${20 + 40 * heatNorm},100%,${40 + 10 * heatNorm}%)`;
          ctx.fillStyle = color;
          ctx.fillRect(40, canvas.height - 40 - heatNorm * (canvas.height - 80), canvas.width - 80, heatNorm * (canvas.height - 80));

          ctx.fillStyle = "#9aa0d2";
          ctx.font = "12px system-ui";
          ctx.fillText(`Heat: ${Math.round(heat)}`, 10, 18);
          ctx.fillText(`Stability: ${Math.round(stability)}`, 10, 34);
          if (!running) ctx.fillText("Run finished. Switch games to reset.", 10, 52);
        }
      };
    }

    /* ==========================
       Bloomcraft
       ========================== */
    function createBloomcraft() {
      const blooms = [];
      const maxBlooms = 5;
      let timer = 0;

      for (let i = 0; i < maxBlooms; i++) {
        blooms.push({
          growth: Math.random() * 20,
          mutation: 0,
          color: baseColors[Math.floor(Math.random() * baseColors.length)],
          rarity: randomRarity()
        });
      }

      return {
        update(dt) {
          timer += dt;
          if (timer > 2000) {
            timer = 0;
            for (const b of blooms) {
              b.growth += 5 + Math.random() * 10;
              const mutWeather = getCurrentWeather();
              if (Math.random() < mutateChance(mutWeather)) {
                b.mutation += 10 + Math.random() * 10;
              }
            }
            const totalScore = blooms.reduce((s, b) => s + b.growth + b.mutation * 2, 0);
            const score = Math.round(totalScore);
            const u = getUser();
            if (u) {
              u.lastScores.bloomcraft = score;
              saveState();
              submitScore("bloomcraft", score);
            }
          }
        },
        render() {
          ctx.fillStyle = "#050617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          const gap = canvas.width / (blooms.length + 1);
          blooms.forEach((b, i) => {
            const x = gap * (i + 1);
            const baseY = canvas.height - 20;
            const height = Math.min(100, b.growth + b.mutation);
            ctx.strokeStyle = "#4ef09e";
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(x, baseY);
            ctx.lineTo(x, baseY - height);
            ctx.stroke();

            ctx.fillStyle = b.color.hex;
            ctx.beginPath();
            ctx.arc(x, baseY - height, 10 + b.mutation * 0.2, 0, Math.PI * 2);
            ctx.fill();
          });

          ctx.fillStyle = "#9aa0d2";
          ctx.font = "12px system-ui";
          ctx.fillText(`Weather: ${getCurrentWeather()}`, 10, 18);
          ctx.fillText("Blooms grow & mutate automatically.", 10, 34);
        }
      };
    }

    /* ==========================
       Voltline
       ========================== */
    function createVoltline() {
      const nodes = [];
      const nodeCount = 8;
      let chain = 0;
      let alive = true;

      for (let i = 0; i < nodeCount; i++) {
        nodes.push({
          x: 40 + i * ((canvas.width - 80) / (nodeCount - 1)),
          y: canvas.height / 2 + (Math.random() - 0.5) * 60,
          charge: 0,
          overload: 100 + Math.random() * 50
        });
      }

      function clickHandler(e) {
        if (!alive) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        for (const n of nodes) {
          const dx = x - n.x;
          const dy = y - n.y;
          if (dx * dx + dy * dy <= 12 * 12) {
            n.charge += 20 + Math.random() * 15;
            chain++;
            const idx = nodes.indexOf(n);
            if (idx > 0) nodes[idx - 1].charge += 5;
            if (idx < nodes.length - 1) nodes[idx + 1].charge += 5;
            if (n.charge > n.overload) {
              alive = false;
              const score = chain;
              log(`Voltline overloaded at chain ${score}.`);
              submitScore("voltline", score);
            }
            break;
          }
        }
      }

      canvas.addEventListener("click", clickHandler);

      return {
        update(dt) {
          if (!alive) return;
          for (const n of nodes) {
            n.charge -= dt * 0.01;
            if (n.charge < 0) n.charge = 0;
          }
        },
        render() {
          ctx.fillStyle = "#050617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.strokeStyle = "#272b4b";
          ctx.lineWidth = 2;
          ctx.beginPath();
          nodes.forEach((n, i) => {
            if (i === 0) ctx.moveTo(n.x, n.y);
            else ctx.lineTo(n.x, n.y);
          });
          ctx.stroke();

          nodes.forEach(n => {
            const t = Math.min(1, n.charge / n.overload);
            const col = `hsl(${40 + 80 * (1 - t)},100%,${40 + 10 * t}%)`;
            ctx.fillStyle = col;
            ctx.beginPath();
            ctx.arc(n.x, n.y, 8 + t * 4, 0, Math.PI * 2);
            ctx.fill();
          });

          ctx.fillStyle = "#9aa0d2";
          ctx.font = "12px system-ui";
          ctx.fillText(`Chain: ${chain}`, 10, 18);
          if (!alive) ctx.fillText("Overloaded. Switch games to reset.", 10, 34);
        }
      };
    }

    /* ==========================
       Cryoshift
       ========================== */
    function createCryoshift() {
      let value = 50;
      let stability = 100;
      let frozen = false;

      function keyHandler(e) {
        if (e.code === "Space") frozen = !frozen;
      }
      window.addEventListener("keydown", keyHandler);

      return {
        update(dt) {
          if (frozen) {
            value += dt * 0.02;
            stability -= dt * 0.02;
          } else {
            value += dt * 0.005;
            stability += dt * 0.01;
            if (stability > 100) stability = 100;
          }
          if (stability <= 0) {
            stability = 0;
            const score = Math.round(value);
            log(`Cryoshift shard shattered at value ${score}.`);
            submitScore("cryoshift", score);
            value = 50;
            stability = 100;
          }
        },
        render() {
          ctx.fillStyle = "#050617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          const centerX = canvas.width / 2;
          const centerY = canvas.height / 2;
          const size = 40 + (value - 50) * 0.1;

          ctx.fillStyle = frozen ? "#4ef0ff" : "#9aa0d2";
          ctx.beginPath();
          ctx.moveTo(centerX, centerY - size);
          ctx.lineTo(centerX + size, centerY);
          ctx.lineTo(centerX, centerY + size);
          ctx.lineTo(centerX - size, centerY);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = "#9aa0d2";
          ctx.font = "12px system-ui";
          ctx.fillText(`Value: ${Math.round(value)}`, 10, 18);
          ctx.fillText(`Stability: ${Math.round(stability)}`, 10, 34);
          ctx.fillText(`Mode: ${frozen ? "Frozen" : "Thawing"}`, 10, 50);
        }
      };
    }

    /* ==========================
       Riftweave
       ========================== */
    function createRiftweave() {
      const threads = [];
      const maxThreads = 6;
      let tension = 0;
      let score = 0;
      let alive = true;

      for (let i = 0; i < maxThreads; i++) {
        threads.push({
          x1: Math.random() * canvas.width,
          y1: Math.random() * canvas.height,
          x2: Math.random() * canvas.width,
          y2: Math.random() * canvas.height,
          color: baseColors[Math.floor(Math.random() * baseColors.length)].hex
        });
      }

      function clickHandler() {
        if (!alive) return;
        tension += 10;
        score += 5 + Math.floor(Math.random() * 10);
        if (Math.random() < tension / 200) {
          alive = false;
          log(`Riftweave collapsed at score ${score}.`);
          submitScore("riftweave", score);
        } else {
          threads.push({
            x1: Math.random() * canvas.width,
            y1: Math.random() * canvas.height,
            x2: Math.random() * canvas.width,
            y2: Math.random() * canvas.height,
            color: baseColors[Math.floor(Math.random() * baseColors.length)].hex
          });
        }
      }

      canvas.addEventListener("click", clickHandler);

      return {
        update(dt) {
          if (!alive) return;
          tension -= dt * 0.005;
          if (tension < 0) tension = 0;
        },
        render() {
          ctx.fillStyle = "#050617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          threads.forEach(t => {
            ctx.strokeStyle = t.color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(t.x1, t.y1);
            ctx.lineTo(t.x2, t.y2);
            ctx.stroke();
          });

          ctx.fillStyle = "#9aa0d2";
          ctx.font = "12px system-ui";
          ctx.fillText(`Tension: ${Math.round(tension)}`, 10, 18);
          ctx.fillText(`Score: ${score}`, 10, 34);
          if (!alive) ctx.fillText("Pattern collapsed. Switch games to reset.", 10, 50);
        }
      };
    }

    /* ==========================
       Phase Runner
       ========================== */
    function createPhaseRunner() {
      const lanes = [canvas.height * 0.25, canvas.height * 0.5, canvas.height * 0.75];
      let laneIndex = 1;
      let playerX = canvas.width * 0.2;
      let speed = 0.18;
      let distance = 0;
      let obstacles = [];
      let alive = true;
      let spawnTimer = 0;

      function spawnObstacle() {
        obstacles.push({
          x: canvas.width + 20,
          lane: Math.floor(Math.random() * 3),
          w: 18,
          h: 18
        });
      }

      function keyHandler(e) {
        if (!alive) return;
        if (e.code === "ArrowUp" || e.code === "KeyW") laneIndex = Math.max(0, laneIndex - 1);
        else if (e.code === "ArrowDown" || e.code === "KeyS") laneIndex = Math.min(2, laneIndex + 1);
      }
      window.addEventListener("keydown", keyHandler);

      return {
        update(dt) {
          if (!alive) return;
          const dts = dt;
          distance += dts * 0.04;
          spawnTimer += dts;
          if (spawnTimer > 1100) {
            spawnTimer = 0;
            spawnObstacle();
            speed += 0.003;
          }
          obstacles.forEach(o => { o.x -= speed * dts; });
          obstacles = obstacles.filter(o => o.x + o.w > -10);

          const py = lanes[laneIndex];
          for (const o of obstacles) {
            if (o.lane === laneIndex) {
              const dx = Math.abs((o.x + o.w / 2) - playerX);
              if (dx < 14) {
                alive = false;
                const score = Math.round(distance);
                log(`Phase Runner hit an obstacle at distance ${score}.`);
                submitScore("phaseRunner", score);
                break;
              }
            }
          }
        },
        render() {
          ctx.fillStyle = "#050617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.strokeStyle = "#272b4b";
          ctx.lineWidth = 1;
          lanes.forEach(y => {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
          });

          const py = lanes[laneIndex];
          ctx.fillStyle = "#4ef0ff";
          ctx.beginPath();
          ctx.arc(playerX, py, 10, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = "#ff5e7a";
          obstacles.forEach(o => {
            const y = lanes[o.lane];
            ctx.fillRect(o.x, y - 9, o.w, o.h);
          });

          ctx.fillStyle = "#9aa0d2";
          ctx.font = "12px system-ui";
          ctx.fillText(`Distance: ${Math.round(distance)}`, 10, 18);
        }
      };
    }

    /* ==========================
       Precision Pulse
       ========================== */
    function createPrecisionPulse() {
      let t = 0;
      let pulseInterval = 2000;
      let pulseCenter = 1000;
      let waitingForHit = true;
      let lastHitError = null;
      let scoreSum = 0;
      let attempts = 0;

      function keyHandler(e) {
        if (e.code === "Space" && waitingForHit) {
          waitingForHit = false;
          const error = Math.abs(t - pulseCenter);
          lastHitError = error;
          const accuracy = Math.max(0, 100 - error / 10);
          scoreSum += accuracy;
          attempts++;
          const avgScore = Math.round(scoreSum / attempts);
          log(`Precision Pulse hit error: ${Math.round(error)} ms, accuracy: ${Math.round(accuracy)}%.`);
          submitScore("precisionPulse", avgScore);
        }
      }
      window.addEventListener("keydown", keyHandler);

      function resetPulse() {
        t = 0;
        pulseInterval = 1500 + Math.random() * 1200;
        pulseCenter = 600 + Math.random() * (pulseInterval - 600);
        waitingForHit = true;
        lastHitError = null;
      }

      resetPulse();

      return {
        update(dt) {
          t += dt;
          if (t > pulseInterval) resetPulse();
        },
        render() {
          ctx.fillStyle = "#050617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          const barY = canvas.height / 2;
          const barMargin = 30;
          const barWidth = canvas.width - barMargin * 2;
          ctx.strokeStyle = "#272b4b";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(barMargin, barY);
          ctx.lineTo(canvas.width - barMargin, barY);
          ctx.stroke();

          const centerX = barMargin + (pulseCenter / pulseInterval) * barWidth;
          ctx.strokeStyle = "#4ef0ff";
          ctx.beginPath();
          ctx.moveTo(centerX, barY - 10);
          ctx.lineTo(centerX, barY + 10);
          ctx.stroke();

          const markerX = barMargin + (t / pulseInterval) * barWidth;
          ctx.fillStyle = "#ff5e7a";
          ctx.beginPath();
          ctx.arc(markerX, barY, 6, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = "#9aa0d2";
          ctx.font = "12px system-ui";
          ctx.fillText("Press Space as close as possible to the center marker.", 10, 18);
          if (lastHitError !== null) {
            const acc = Math.max(0, 100 - lastHitError / 10);
            ctx.fillText(`Last error: ${Math.round(lastHitError)} ms (Accuracy: ${Math.round(acc)}%)`, 10, 34);
          }
        }
      };
    }

    /* ==========================
       Shard Towers (new game)
       ========================== */
    function createShardTowers() {
      const u = getUser();
      if (!u.shardTowers) {
        u.shardTowers = {
          shards: 0,
          towers: [
            { name: "Small Tower", level: 0, baseCost: 50, gain: 1 },
            { name: "Medium Tower", level: 0, baseCost: 150, gain: 4 },
            { name: "Large Tower", level: 0, baseCost: 400, gain: 10 }
          ]
        };
      }
      let timer = 0;

      function buyTower(idx) {
        const t = u.shardTowers.towers[idx];
        const cost = Math.round(t.baseCost * Math.pow(1.6, t.level));
        if (u.currency < cost) {
          log("Not enough credits for this tower.");
          return;
        }
        u.currency -= cost;
        t.level++;
        saveState();
        updateCurrency();
        log(`Bought ${t.name} level ${t.level}.`);
      }

      // simple UI: draw tower info and let user click buttons area
      canvas.addEventListener("click", onClick);

      function onClick(e) {
        const rect = canvas.getBoundingClientRect();
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        const idx = Math.floor((y - 50) / 40);
        if (idx >= 0 && idx < u.shardTowers.towers.length) buyTower(idx);
      }

      return {
        update(dt) {
          timer += dt;
          if (timer > 1000) {
            timer = 0;
            let gainPerTick = 0;
            u.shardTowers.towers.forEach(t => {
              gainPerTick += t.level * t.gain;
            });
            u.shardTowers.shards += gainPerTick;
            saveState();
          }
        },
        render() {
          ctx.fillStyle = "#050617";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          ctx.fillStyle = "#9aa0d2";
          ctx.font = "12px system-ui";
          ctx.fillText(`Shards: ${u.shardTowers.shards}`, 10, 20);
          ctx.fillText("Click tower rows to buy levels.", 10, 36);

          u.shardTowers.towers.forEach((t, i) => {
            const y = 50 + i * 40;
            const cost = Math.round(t.baseCost * Math.pow(1.6, t.level));
            ctx.fillStyle = "#111325";
            ctx.fillRect(10, y - 14, canvas.width - 20, 28);

            ctx.fillStyle = "#f4f7ff";
            ctx.fillText(`${t.name} (Lv ${t.level})`, 16, y - 2);
            ctx.fillStyle = "#9aa0d2";
            ctx.fillText(`Next cost: ${cost} credits · Gain: +${t.gain}/tick`, 16, y + 12);
          });
        }
      };
    }
  </script>
</body>
</html>
