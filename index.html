<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Nexus Arcade</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #050617;
      --bg-alt: #080a1f;
      --accent: #ff5ef7;
      --accent2: #4ef0ff;
      --card-bg: #111325;
      --card-border: #272b4b;
      --text-main: #f4f7ff;
      --text-muted: #9aa0d2;
      --danger: #ff5e7a;
      --success: #4ef09e;
      --warning: #ffc857;
      --shadow-strong: 0 20px 40px rgba(0, 0, 0, 0.5);
      --radius-lg: 18px;
      --radius-md: 12px;
      --radius-pill: 999px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
    }

    body {
      background: radial-gradient(circle at top, #1d1f44, #050617 55%, #000 100%);
      color: var(--text-main);
      min-height: 100vh;
      padding: 32px 16px 40px;
      display: flex;
      justify-content: center;
    }

    .app {
      width: 100%;
      max-width: 1200px;
    }

    header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
    }

    .title-block {
      display: flex;
      align-items: center;
      gap: 14px;
    }

    .logo {
      width: 48px;
      height: 48px;
      border-radius: 18px;
      background: conic-gradient(
        from 180deg,
        var(--accent),
        var(--accent2),
        #ffb347,
        var(--accent)
      );
      box-shadow: 0 0 40px rgba(255, 94, 247, 0.8);
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: 900;
      font-size: 20px;
      color: #050617;
    }

    h1 {
      font-size: 28px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
    }

    .subtitle {
      font-size: 13px;
      color: var(--text-muted);
      margin-top: 2px;
    }

    .controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .pill {
      border-radius: var(--radius-pill);
      padding: 8px 14px;
      font-size: 12px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      background: linear-gradient(
        135deg,
        rgba(255, 94, 247, 0.12),
        rgba(78, 240, 255, 0.05)
      );
      color: var(--text-muted);
    }

    .pill strong {
      color: var(--accent2);
      font-size: 13px;
    }

    .btn {
      border-radius: var(--radius-pill);
      padding: 8px 16px;
      border: none;
      cursor: pointer;
      font-size: 13px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: linear-gradient(135deg, var(--accent), var(--accent2));
      color: #050617;
      box-shadow: var(--shadow-strong);
      display: inline-flex;
      align-items: center;
      gap: 8px;
    }

    .btn span {
      font-size: 11px;
      opacity: 0.8;
    }

    main {
      background: linear-gradient(145deg, #050617, #111325);
      border-radius: 26px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      box-shadow: var(--shadow-strong);
      padding: 18px 18px 22px;
      position: relative;
      overflow: hidden;
    }

    main::before {
      content: "";
      position: absolute;
      inset: -40%;
      opacity: 0.35;
      background:
        radial-gradient(circle at 10% 0%, rgba(255, 94, 247, 0.18) 0, transparent 40%),
        radial-gradient(circle at 90% 0%, rgba(78, 240, 255, 0.18) 0, transparent 40%);
      pointer-events: none;
    }

    .main-inner {
      position: relative;
      z-index: 1;
    }

    .top-row {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 16px;
      margin-bottom: 14px;
      flex-wrap: wrap;
    }

    .stats {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .stat-card {
      background: rgba(7, 9, 28, 0.9);
      border-radius: var(--radius-md);
      border: 1px solid rgba(255, 255, 255, 0.06);
      padding: 8px 12px;
      min-width: 120px;
    }

    .stat-label {
      font-size: 11px;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      margin-bottom: 4px;
    }

    .stat-value {
      font-size: 16px;
      font-weight: 600;
    }

    .stat-value span {
      font-size: 11px;
      color: var(--accent2);
      margin-left: 4px;
    }

    .filter-bar {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .filter-chip {
      border-radius: var(--radius-pill);
      padding: 6px 12px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.16);
      background: rgba(9, 10, 40, 0.95);
      color: var(--text-muted);
    }

    .filter-chip.active {
      border-color: var(--accent);
      color: var(--accent);
      background: radial-gradient(circle at top left, rgba(255, 94, 247, 0.2), transparent 60%);
    }

    .grid {
      margin-top: 10px;
      display: grid;
      gap: 14px;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
    }

    .game-card {
      position: relative;
      border-radius: var(--radius-lg);
      background: radial-gradient(circle at top left, #22254a, #0a0c23);
      border: 1px solid var(--card-border);
      padding: 12px;
      overflow: hidden;
      cursor: pointer;
      transition: transform 0.18s ease, box-shadow 0.18s ease, border-color 0.18s ease,
        background 0.18s ease;
    }

    .game-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 18px 30px rgba(0, 0, 0, 0.55);
      border-color: rgba(255, 255, 255, 0.5);
      background: radial-gradient(circle at top left, #2f3468, #050617);
    }

    .game-tag {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 4px 9px;
      font-size: 10px;
      border-radius: var(--radius-pill);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      background: rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.25);
    }

    .game-tag.reaction {
      border-color: var(--accent2);
      color: var(--accent2);
    }

    .game-tag.memory {
      border-color: var(--accent);
      color: var(--accent);
    }

    .game-tag.survival {
      border-color: var(--danger);
      color: var(--danger);
    }

    .game-tag.logic {
      border-color: var(--success);
      color: var(--success);
    }

    .thumb {
      height: 90px;
      border-radius: 12px;
      background: radial-gradient(circle at 10% 0, rgba(255, 255, 255, 0.12), transparent 55%),
        radial-gradient(circle at 90% 100%, rgba(0, 0, 0, 0.6), transparent 57%),
        linear-gradient(135deg, #151633, #050617);
      overflow: hidden;
      margin-bottom: 10px;
      position: relative;
    }

    .thumb-canvas {
      width: 100%;
      height: 100%;
      background:
        repeating-linear-gradient(
          135deg,
          rgba(255, 255, 255, 0.05),
          rgba(255, 255, 255, 0.05) 2px,
          transparent 2px,
          transparent 6px
        );
      position: absolute;
      inset: 0;
      opacity: 0.7;
    }

    .thumb-orbit {
      position: absolute;
      width: 60%;
      height: 60%;
      border-radius: 999px;
      border: 1px dashed rgba(255, 255, 255, 0.2);
      top: 20%;
      left: 20%;
    }

    .thumb-orbit::after {
      content: "";
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: var(--accent2);
      box-shadow: 0 0 12px rgba(78, 240, 255, 0.85);
      top: -5px;
      right: 8px;
    }

    .thumb-pulse {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 999px;
      border: 2px solid rgba(255, 94, 247, 0.6);
      left: 16px;
      bottom: 16px;
    }

    .thumb-pulse::after {
      content: "";
      position: absolute;
      inset: 3px;
      border-radius: inherit;
      background: radial-gradient(circle, rgba(255, 94, 247, 0.6), transparent);
    }

    .card-title {
      font-size: 14px;
      font-weight: 700;
      margin-bottom: 4px;
    }

    .card-desc {
      font-size: 11px;
      color: var(--text-muted);
      min-height: 30px;
      margin-bottom: 6px;
    }

    .card-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 10px;
    }

    .pill-small {
      border-radius: var(--radius-pill);
      padding: 3px 7px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .difficulty {
      display: flex;
      gap: 2px;
      align-items: center;
    }

    .dot {
      width: 7px;
      height: 7px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.15);
    }

    .dot.on {
      background: var(--accent2);
      box-shadow: 0 0 6px rgba(78, 240, 255, 0.9);
    }

    .dot.hard {
      background: var(--danger);
      box-shadow: 0 0 6px rgba(255, 94, 122, 0.9);
    }

    footer {
      margin-top: 18px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 11px;
      color: var(--text-muted);
      gap: 12px;
      flex-wrap: wrap;
    }

    footer span strong {
      color: var(--accent2);
    }

    .ticker {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .ticker-pill {
      border-radius: var(--radius-pill);
      padding: 4px 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(7, 9, 28, 0.88);
    }

    /* Modal / game container */

    .overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.85);
      display: none;
      justify-content: center;
      align-items: center;
      padding: 12px;
      z-index: 50;
    }

    .overlay.active {
      display: flex;
    }

    .game-shell {
      width: 100%;
      max-width: 960px;
      background: radial-gradient(circle at top left, #272b5e, #050617);
      border-radius: 24px;
      border: 1px solid rgba(255, 255, 255, 0.13);
      box-shadow: 0 30px 80px rgba(0, 0, 0, 0.7);
      padding: 14px 16px 16px;
      position: relative;
      color: #f8f8ff;
    }

    .game-shell-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 10px;
      margin-bottom: 8px;
    }

    .game-shell-header-left {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .game-shell-title {
      font-size: 15px;
      font-weight: 700;
    }

    .game-shell-sub {
      font-size: 11px;
      color: var(--text-muted);
    }

    .game-shell-controls {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .ghost-btn {
      border-radius: var(--radius-pill);
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(8, 10, 30, 0.9);
      padding: 5px 10px;
      font-size: 11px;
      cursor: pointer;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--text-muted);
    }

    .ghost-btn.primary {
      border-color: var(--accent2);
      color: var(--accent2);
    }

    .ghost-btn.danger {
      border-color: var(--danger);
      color: var(--danger);
    }

    .game-layout {
      display: grid;
      grid-template-columns: minmax(0, 3fr) minmax(0, 2fr);
      gap: 10px;
      margin-top: 6px;
    }

    @media (max-width: 800px) {
      .game-layout {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    .canvas-wrap {
      background: radial-gradient(circle at top, #151633, #050617);
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      padding: 8px;
      position: relative;
    }

    canvas {
      display: block;
      background: #050617;
      border-radius: 14px;
      width: 100%;
      height: 260px;
      image-rendering: pixelated;
    }

    @media (max-width: 600px) {
      canvas {
        height: 220px;
      }
    }

    .info-panel {
      background: rgba(5, 6, 23, 0.95);
      border-radius: 18px;
      border: 1px solid rgba(255, 255, 255, 0.16);
      padding: 10px 12px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      font-size: 11px;
    }

    .info-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    .info-label {
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.12em;
      font-size: 10px;
    }

    .info-value {
      font-size: 12px;
      font-weight: 600;
    }

    .info-value.accent {
      color: var(--accent2);
    }

    .info-value.danger {
      color: var(--danger);
    }

    .info-body {
      margin-top: 2px;
      line-height: 1.5;
      color: var(--text-muted);
    }

    .kbd {
      padding: 2px 5px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.25);
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
    }

    .close-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      border-radius: 999px;
      width: 26px;
      height: 26px;
      display: flex;
      justify-content: center;
      align-items: center;
      cursor: pointer;
      border: 1px solid rgba(255, 255, 255, 0.35);
      background: rgba(5, 6, 23, 0.9);
      font-size: 13px;
      color: var(--text-muted);
    }

    .close-btn:hover {
      background: rgba(255, 94, 122, 0.15);
      color: var(--danger);
    }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="title-block">
        <div class="logo">NX</div>
        <div>
          <h1>Nexus Arcade</h1>
          <div class="subtitle">20 ultra‑replayable micro‑games · all in one neon hub</div>
        </div>
      </div>
      <div class="controls">
        <div class="pill">
          Daily combo:
          <strong id="daily-combo">Reaction · Memory · Survival</strong>
        </div>
        <button class="btn" id="random-game-btn">
          Play random
          <span>Reroll with space</span>
        </button>
      </div>
    </header>

    <main>
      <div class="main-inner">
        <div class="top-row">
          <div class="stats">
            <div class="stat-card">
              <div class="stat-label">Games</div>
              <div class="stat-value" id="stat-games">20 <span>modes</span></div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Best streak</div>
              <div class="stat-value" id="stat-streak">0 <span>wins</span></div>
            </div>
            <div class="stat-card">
              <div class="stat-label">Time played</div>
              <div class="stat-value" id="stat-time">0:00 <span>session</span></div>
            </div>
          </div>
          <div class="filter-bar">
            <button class="filter-chip active" data-filter="all">All</button>
            <button class="filter-chip" data-filter="reaction">Reaction</button>
            <button class="filter-chip" data-filter="memory">Memory</button>
            <button class="filter-chip" data-filter="survival">Survival</button>
            <button class="filter-chip" data-filter="logic">Logic</button>
          </div>
        </div>

        <div class="grid" id="game-grid">
          <!-- Cards injected by JS -->
        </div>

        <footer>
          <span>Built for <strong>quick sessions</strong> and long marathons. All scores are client‑side only.</span>
          <div class="ticker">
            <div class="ticker-pill">Tip: press <span class="kbd">space</span> to hop between games.</div>
            <div class="ticker-pill">Most games: mouse or arrow keys only.</div>
          </div>
        </footer>
      </div>
    </main>
  </div>

  <!-- Modal / game container -->
  <div class="overlay" id="overlay">
    <div class="game-shell">
      <button class="close-btn" id="close-overlay">&times;</button>
      <div class="game-shell-header">
        <div class="game-shell-header-left">
          <div class="game-shell-title" id="game-title">Game title</div>
          <div class="game-shell-sub" id="game-sub">Game subtitle / mode</div>
        </div>
        <div class="game-shell-controls">
          <button class="ghost-btn danger" id="quit-btn">Quit</button>
          <button class="ghost-btn primary" id="restart-btn">Restart</button>
        </div>
      </div>
      <div class="game-layout">
        <div class="canvas-wrap">
          <canvas id="game-canvas" width="480" height="270"></canvas>
        </div>
        <aside class="info-panel">
          <div class="info-row">
            <span class="info-label">Mode</span>
            <span class="info-value" id="info-mode">Reaction</span>
          </div>
          <div class="info-row">
            <span class="info-label">High score</span>
            <span class="info-value accent" id="info-high">0</span>
          </div>
          <div class="info-row">
            <span class="info-label">Last run</span>
            <span class="info-value danger" id="info-last">No runs yet</span>
          </div>
          <div class="info-row">
            <span class="info-label">Controls</span>
            <span class="info-value" id="info-controls"></span>
          </div>
          <div class="info-body" id="info-body">
            Hover over cards in the hub to see quick descriptions. Each mode tweaks difficulty, speed or rules to stay fresh.
          </div>
        </aside>
      </div>
    </div>
  </div>

  <script>
    // --------- Game hub data ---------
    const games = [
      {
        id: "reaction-1",
        name: "Photon Reflex",
        subtitle: "Classic reaction test",
        description: "Wait for the arena to flash, then click as fast as you can. Consistency beats luck.",
        tag: "reaction",
        difficulty: 2,
        variant: "reaction",
        params: { minDelay: 800, maxDelay: 2600 }
      },
      {
        id: "reaction-2",
        name: "Quantum Reflex",
        subtitle: "Fast‑twitch challenge",
        description: "The arena might fake you out with dark flashes. React only to bright cyan.",
        tag: "reaction",
        difficulty: 3,
        variant: "reaction-bait",
        params: { minDelay: 600, maxDelay: 2100, baitChance: 0.35 }
      },
      {
        id: "reaction-3",
        name: "Tunnel Reflex",
        subtitle: "Multi‑round speed ladder",
        description: "Survive 5 increasingly aggressive rounds. Average time is what counts.",
        tag: "reaction",
        difficulty: 4,
        variant: "reaction-multi",
        params: { rounds: 5, minDelay: 700, maxDelay: 2500 }
      },
      {
        id: "memory-1",
        name: "Neon Pairs",
        subtitle: "4×4 memory grid",
        description: "Flip panels two at a time. Remember positions and clear the grid in as few moves as possible.",
        tag: "memory",
        difficulty: 2,
        variant: "memory",
        params: { rows: 4, cols: 4 }
      },
      {
        id: "memory-2",
        name: "Echo Matrix",
        subtitle: "5×4 hard mode",
        description: "More tiles, more distraction. Can you still keep a perfect streak?",
        tag: "memory",
        difficulty: 3,
        variant: "memory",
        params: { rows: 4, cols: 5 }
      },
      {
        id: "memory-3",
        name: "Ghost Sequence",
        subtitle: "Simon‑style pattern",
        description: "Watch the orbiting lights then reproduce the sequence by clicking the quadrants.",
        tag: "memory",
        difficulty: 3,
        variant: "simon",
        params: { pads: 4 }
      },
      {
        id: "memory-4",
        name: "Nova Sequence",
        subtitle: "Fast pattern build",
        description: "Patterns grow quickly. One mistake resets the run, so stay locked in.",
        tag: "memory",
        difficulty: 4,
        variant: "simon",
        params: { pads: 4, fast: true }
      },
      {
        id: "survival-1",
        name: "Void Runner",
        subtitle: "Dodge‑the‑blocks",
        description: "Use arrow keys to slide left and right. How long can you last in the falling‑block storm?",
        tag: "survival",
        difficulty: 2,
        variant: "dodger",
        params: { speed: 2 }
      },
      {
        id: "survival-2",
        name: "Meteor Drift",
        subtitle: "Faster dodging",
        description: "Same rules, more chaos. You’ll need predictive movement rather than last‑second dodges.",
        tag: "survival",
        difficulty: 3,
        variant: "dodger",
        params: { speed: 3.3 }
      },
      {
        id: "survival-3",
        name: "Singularity Field",
        subtitle: "Tiny hitbox, dense rain",
        description: "You’re smaller but so are the gaps. Micro‑dodges make all the difference.",
        tag: "survival",
        difficulty: 4,
        variant: "dodger",
        params: { speed: 3.8, tinyPlayer: true }
      },
      {
        id: "logic-1",
        name: "Chrono Tap",
        subtitle: "1‑to‑16 grid",
        description: "Click numbers in ascending order as quickly as possible. Misclicks cost time.",
        tag: "logic",
        difficulty: 2,
        variant: "number-grid",
        params: { size: 4 }
      },
      {
        id: "logic-2",
        name: "Chrono Tap XL",
        subtitle: "1‑to‑25 grid",
        description: "Same rules, bigger grid. Find your scanning rhythm.",
        tag: "logic",
        difficulty: 3,
        variant: "number-grid",
        params: { size: 5 }
      },
      {
        id: "logic-3",
        name: "Flux Type",
        subtitle: "Typing sprint",
        description: "Type the falling codes before they hit the floor. Accuracy multiplies score.",
        tag: "logic",
        difficulty: 3,
        variant: "typing",
        params: { spawnRate: 1800 }
      },
      {
        id: "logic-4",
        name: "Flux Type Turbo",
        subtitle: "Harder typing sprint",
        description: "Shorter words but brutal spawn speed. Don’t let your buffer overflow.",
        tag: "logic",
        difficulty: 4,
        variant: "typing",
        params: { spawnRate: 1100 }
      },
      {
        id: "reaction-4",
        name: "Pulse Catcher",
        subtitle: "Target clicker",
        description: "Click glowing orbs before they fade. Misses hurt your combo.",
        tag: "reaction",
        difficulty: 2,
        variant: "target-click",
        params: { lifetime: 1100 }
      },
      {
        id: "reaction-5",
        name: "Pulse Storm",
        subtitle: "Dense target field",
        description: "Multiple orbs are active at once. Decide which one is worth your next click.",
        tag: "reaction",
        difficulty: 3,
        variant: "target-click",
        params: { lifetime: 900, multi: true }
      },
      {
        id: "survival-4",
        name: "Grid Snake",
        subtitle: "Classic snake loop",
        description: "Arrow keys to move, no walls, no mercy. How big can you get without biting yourself?",
        tag: "survival",
        difficulty: 3,
        variant: "snake",
        params: { speed: 120 }
      },
      {
        id: "survival-5",
        name: "Edge Snake",
        subtitle: "Walls are lethal",
        description: "This time the border is deadly. Gaps feel a lot tighter now.",
        tag: "survival",
        difficulty: 4,
        variant: "snake",
        params: { speed: 110, walls: true }
      },
      {
        id: "logic-5",
        name: "Phase Shift",
        subtitle: "Mini maze",
        description: "Guide the cube to the goal while the maze pulses. Time your runs between wall shifts.",
        tag: "logic",
        difficulty: 2,
        variant: "maze",
        params: { size: 9 }
      },
      {
        id: "logic-6",
        name: "Phase Shift Plus",
        subtitle: "Compact, tricky maze",
        description: "Shorter distance, nastier layout. You’ll need to rethink your routes.",
        tag: "logic",
        difficulty: 3,
        variant: "maze",
        params: { size: 11 }
      }
    ];

    // --------- Hub rendering ---------
    const grid = document.getElementById("game-grid");

    function createDifficultyDots(level) {
      const dots = [];
      for (let i = 1; i <= 4; i++) {
        const on = i <= level;
        dots.push(
          `<div class="dot ${on ? "on" : ""} ${on && level >= 4 ? "hard" : ""}"></div>`
        );
      }
      return dots.join("");
    }

    function renderCards(filter = "all") {
      grid.innerHTML = "";
      for (const game of games) {
        if (filter !== "all" && game.tag !== filter) continue;
        const card = document.createElement("article");
        card.className = "game-card";
        card.dataset.gameId = game.id;
        card.innerHTML = `
          <div class="game-tag ${game.tag}">${game.tag}</div>
          <div class="thumb">
            <div class="thumb-canvas"></div>
            <div class="thumb-orbit"></div>
            <div class="thumb-pulse"></div>
          </div>
          <div class="card-title">${game.name}</div>
          <div class="card-desc">${game.description}</div>
          <div class="card-footer">
            <div class="pill-small">${game.subtitle}</div>
            <div class="difficulty">${createDifficultyDots(game.difficulty)}</div>
          </div>
        `;
        grid.appendChild(card);
      }
    }

    renderCards();

    // Filters
    const filterButtons = document.querySelectorAll(".filter-chip");
    filterButtons.forEach(btn => {
      btn.addEventListener("click", () => {
        filterButtons.forEach(b => b.classList.remove("active"));
        btn.classList.add("active");
        renderCards(btn.dataset.filter);
      });
    });

    // --------- Stats / timers ---------
    let bestStreak = 0;
    let currentStreak = 0;
    let sessionSeconds = 0;
    setInterval(() => {
      sessionSeconds++;
      const minutes = Math.floor(sessionSeconds / 60);
      const seconds = sessionSeconds % 60;
      document.getElementById("stat-time").textContent =
        `${minutes}:${seconds.toString().padStart(2, "0")} session`;
    }, 1000);

    const statStreakEl = document.getElementById("stat-streak");
    function updateStreak(result) {
      if (result === "win") {
        currentStreak++;
        if (currentStreak > bestStreak) bestStreak = currentStreak;
      } else if (result === "loss") {
        currentStreak = 0;
      }
      statStreakEl.textContent = `${bestStreak} wins`;
    }

    // --------- Modal / game engine wiring ---------
    const overlay = document.getElementById("overlay");
    const closeOverlay = document.getElementById("close-overlay");
    const quitBtn = document.getElementById("quit-btn");
    const restartBtn = document.getElementById("restart-btn");
    const canvas = document.getElementById("game-canvas");
    const ctx = canvas.getContext("2d");

    const gameTitleEl = document.getElementById("game-title");
    const gameSubEl = document.getElementById("game-sub");
    const infoModeEl = document.getElementById("info-mode");
    const infoHighEl = document.getElementById("info-high");
    const infoLastEl = document.getElementById("info-last");
    const infoControlsEl = document.getElementById("info-controls");
    const infoBodyEl = document.getElementById("info-body");

    let currentGame = null;
    let currentVariant = null;
    let currentHighscores = {};
    let loopHandle = null;
    let lastTimestamp = 0;

    function stopGameLoop() {
      if (loopHandle) {
        cancelAnimationFrame(loopHandle);
        loopHandle = null;
      }
      if (currentVariant && currentVariant.cleanup) currentVariant.cleanup();
      currentVariant = null;
      currentGame = null;
    }

    function startGameLoop(variant) {
      currentVariant = variant;
      lastTimestamp = performance.now();
      function loop(timestamp) {
        const dt = timestamp - lastTimestamp;
        lastTimestamp = timestamp;
        if (currentVariant && currentVariant.update) {
          currentVariant.update(dt);
        }
        if (currentVariant && currentVariant.render) {
          currentVariant.render();
        }
        loopHandle = requestAnimationFrame(loop);
      }
      loopHandle = requestAnimationFrame(loop);
    }

    function openGame(game) {
      stopGameLoop();
      currentGame = game;
      overlay.classList.add("active");
      gameTitleEl.textContent = game.name;
      gameSubEl.textContent = game.subtitle;
      infoModeEl.textContent =
        game.tag.charAt(0).toUpperCase() + game.tag.slice(1);
      infoHighEl.textContent = currentHighscores[game.id] ?? 0;
      infoLastEl.textContent = "No runs yet";
      const controls = variantControls[game.variant] || "Mouse or keys.";
      infoControlsEl.innerHTML = controls;
      infoBodyEl.textContent = game.description;

      const initVariant = variantInitializers[game.variant];
      if (initVariant) {
        const variantInstance = initVariant(game.params, runResult => {
          const prevHigh = currentHighscores[game.id] ?? 0;
          if (runResult.score != null && runResult.score > prevHigh) {
            currentHighscores[game.id] = runResult.score;
            infoHighEl.textContent = runResult.score;
          }
          infoLastEl.textContent =
            runResult.label || `Score: ${runResult.score ?? 0}`;
          updateStreak(runResult.outcome || "loss");
        });
        startGameLoop(variantInstance);
      }
    }

    function closeGame() {
      stopGameLoop();
      overlay.classList.remove("active");
    }

    closeOverlay.addEventListener("click", closeGame);
    quitBtn.addEventListener("click", closeGame);
    restartBtn.addEventListener("click", () => {
      if (currentGame) openGame(currentGame);
    });

    // Card click -> open game
    grid.addEventListener("click", e => {
      const card = e.target.closest(".game-card");
      if (!card) return;
      const id = card.dataset.gameId;
      const game = games.find(g => g.id === id);
      if (game) openGame(game);
    });

    // Random game
    const randomBtn = document.getElementById("random-game-btn");
    function pickRandomGame() {
      return games[Math.floor(Math.random() * games.length)];
    }
    randomBtn.addEventListener("click", () => {
      openGame(pickRandomGame());
    });

    // Spacebar -> random
    window.addEventListener("keydown", e => {
      if (e.code === "Space" && !e.repeat) {
        e.preventDefault();
        if (overlay.classList.contains("active")) {
          openGame(pickRandomGame());
        } else {
          openGame(pickRandomGame());
        }
      }
      if (e.code === "Escape") {
        if (overlay.classList.contains("active")) {
          closeGame();
        }
      }
    });

    // --------- Variant implementations ---------
    const variantControls = {
      "reaction": "Wait until the arena turns <strong>bright cyan</strong>, then <strong>click anywhere</strong> as fast as possible.",
      "reaction-bait": "Ignore dark flashes. Click only when the arena glows <strong>pure cyan</strong>.",
      "reaction-multi": "Play 5 rounds back‑to‑back. Wait for the cyan flash and click quickly each round.",
      "memory": "Click tiles to reveal symbols. Match them in pairs with as few misses as possible.",
      "simon": "Watch the pad sequence, then repeat it by clicking the colored quadrants.",
      "dodger": "Use <span class='kbd'>←</span> <span class='kbd'>→</span> to dodge falling blocks. One hit ends the run.",
      "number-grid": "Click numbers in order starting at 1 as fast as you can.",
      "typing": "Type the codes shown above the lane before they hit the floor. Press <span class='kbd'>enter</span> to submit.",
      "target-click": "Click glowing orbs before they disappear. Misses reduce your combo multiplier.",
      "snake": "Use arrow keys to guide the snake to food. Don’t hit yourself (or walls in Edge mode).",
      "maze": "Use arrow keys to reach the goal square. Some walls pulse in and out—time your movement."
    };

    const variantInitializers = {};

    // --- 1: Reaction basic ---
    variantInitializers["reaction"] = (params, onResult) => {
      const minDelay = params.minDelay ?? 800;
      const maxDelay = params.maxDelay ?? 2200;
      let state = "waiting"; // waiting -> armed -> result
      let startTime = 0;
      let triggerTime = performance.now() + (minDelay + Math.random() * (maxDelay - minDelay));
      let lastTime = performance.now();
      let resultText = "";

      function reset() {
        state = "waiting";
        resultText = "";
        lastTime = performance.now();
        triggerTime = lastTime + (minDelay + Math.random() * (maxDelay - minDelay));
      }

      canvas.onclick = () => {
        const now = performance.now();
        if (state === "waiting") {
          // clicked too early
          resultText = "Too early!";
          onResult({ score: 0, label: "Too early", outcome: "loss" });
          reset();
        } else if (state === "armed") {
          const reaction = Math.round(now - startTime);
          resultText = reaction + " ms";
          onResult({ score: Math.max(1, 1000 - reaction), label: reaction + " ms", outcome: "win" });
          reset();
        }
      };

      function update() {
        const now = performance.now();
        if (state === "waiting" && now >= triggerTime) {
          state = "armed";
          startTime = now;
        }
      }

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        const now = performance.now();
        const armed = state === "armed";

        const progress = state === "waiting"
          ? Math.max(0, Math.min(1, (triggerTime - now) / (maxDelay - minDelay)))
          : 0;

        const bgColor = armed ? "#0ff" : `rgb(${10 + 30 * progress}, ${10 + 50 * progress}, ${40 + 120 * (1 - progress)})`;
        ctx.fillStyle = bgColor;
        ctx.fillRect(0, 0, w, h);

        ctx.fillStyle = "rgba(0,0,0,0.35)";
        for (let x = 0; x < w; x += 20) {
          ctx.fillRect(x, 0, 2, h);
        }

        ctx.fillStyle = armed ? "#020418" : "#c9e4ff";
        ctx.font = "20px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        const mainText = armed ? "CLICK!" : "Wait for cyan, then click";
        ctx.fillText(mainText, w / 2, h / 2);

        ctx.font = "14px system-ui";
        ctx.fillStyle = "#ffffffcc";
        if (resultText) {
          ctx.fillText("Last: " + resultText, w / 2, h * 0.7);
        }
      }

      return { update, render, cleanup() { canvas.onclick = null; } };
    };

    // --- 2: Reaction with baits ---
    variantInitializers["reaction-bait"] = (params, onResult) => {
      const minDelay = params.minDelay ?? 600;
      const maxDelay = params.maxDelay ?? 2100;
      const baitChance = params.baitChance ?? 0.3;
      let state = "waiting";
      let flashColor = "#0ff";
      let triggerTime = performance.now() + minDelay + Math.random() * (maxDelay - minDelay);
      let startTime = 0;
      let resultText = "";

      function reset() {
        state = "waiting";
        resultText = "";
        const now = performance.now();
        triggerTime = now + (minDelay + Math.random() * (maxDelay - minDelay));
      }

      canvas.onclick = () => {
        const now = performance.now();
        if (state === "waiting") {
          resultText = "Too early!";
          onResult({ score: 0, label: "Clicked bait / early", outcome: "loss" });
          reset();
        } else if (state === "armed") {
          const reaction = Math.round(now - startTime);
          resultText = reaction + " ms";
          onResult({ score: Math.max(1, 1100 - reaction), label: reaction + " ms", outcome: "win" });
          reset();
        }
      };

      function update() {
        const now = performance.now();
        if (state === "waiting" && now >= triggerTime) {
          const bait = Math.random() < baitChance;
          flashColor = bait ? "#33334a" : "#0ff";
          const isBait = bait;
          if (isBait) {
            // Bait flash; don't allow a good result
            state = "bait";
            setTimeout(() => {
              if (state === "bait") {
                state = "waiting";
                reset();
              }
            }, 250);
          } else {
            state = "armed";
            startTime = now;
          }
        }
      }

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.fillStyle = state === "waiting" ? "#14162e" : flashColor;
        ctx.fillRect(0, 0, w, h);

        ctx.strokeStyle = "rgba(255,255,255,0.3)";
        ctx.lineWidth = 2;
        ctx.strokeRect(20, 20, w - 40, h - 40);

        ctx.font = "18px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#f8f8ff";
        const txt =
          state === "waiting"
            ? "Wait for bright cyan"
            : state === "armed"
            ? "Click!"
            : "Ignore this flash";
        ctx.fillText(txt, w / 2, h / 2);

        if (resultText) {
          ctx.font = "14px system-ui";
          ctx.fillText("Last: " + resultText, w / 2, h * 0.7);
        }
      }

      return { update, render, cleanup() { canvas.onclick = null; } };
    };

    // --- 3: Reaction multi‑round ---
    variantInitializers["reaction-multi"] = (params, onResult) => {
      const roundsTotal = params.rounds ?? 5;
      const minDelay = params.minDelay ?? 700;
      const maxDelay = params.maxDelay ?? 2500;
      let roundIndex = 0;
      let times = [];
      let state = "waiting";
      let triggerTime = performance.now() + minDelay + Math.random() * (maxDelay - minDelay);
      let startTime = 0;
      let message = "Round 1 / " + roundsTotal;

      function resetRound() {
        const now = performance.now();
        triggerTime = now + (minDelay + Math.random() * (maxDelay - minDelay));
        state = "waiting";
      }

      function finishRun() {
        const avg =
          times.length > 0
            ? Math.round(times.reduce((a, b) => a + b, 0) / times.length)
            : 0;
        const score = Math.max(1, 1000 - avg) * roundsTotal;
        onResult({ score, label: `Avg: ${avg} ms`, outcome: "win" });
        roundIndex = 0;
        times = [];
        message = "Round 1 / " + roundsTotal;
        resetRound();
      }

      canvas.onclick = () => {
        const now = performance.now();
        if (state === "waiting") {
          onResult({ score: 0, label: "Clicked early", outcome: "loss" });
          roundIndex = 0;
          times = [];
          message = "Round 1 / " + roundsTotal;
          resetRound();
        } else if (state === "armed") {
          const reaction = Math.round(now - startTime);
          times.push(reaction);
          roundIndex++;
          if (roundIndex >= roundsTotal) {
            finishRun();
          } else {
            message = `Round ${roundIndex + 1} / ${roundsTotal}`;
            resetRound();
          }
        }
      };

      function update() {
        const now = performance.now();
        if (state === "waiting" && now >= triggerTime) {
          state = "armed";
          startTime = now;
        }
      }

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.fillStyle = state === "armed" ? "#0ff" : "#10122b";
        ctx.fillRect(0, 0, w, h);

        ctx.fillStyle = "#1f2142";
        for (let y = 0; y < h; y += 25) {
          ctx.fillRect(0, y, w, 1);
        }

        ctx.font = "18px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#fefefe";
        ctx.fillText(
          state === "armed" ? "Click!" : "Wait for cyan flash",
          w / 2,
          h / 2
        );

        ctx.font = "14px system-ui";
        ctx.fillText(message, w / 2, h * 0.7);

        if (times.length > 0) {
          const avg = Math.round(
            times.reduce((a, b) => a + b, 0) / times.length
          );
          ctx.font = "12px system-ui";
          ctx.fillText("Current avg: " + avg + " ms", w / 2, h * 0.84);
        }
      }

      return { update, render, cleanup() { canvas.onclick = null; } };
    };

    // --- 4: Memory pairs ---
    variantInitializers["memory"] = (params, onResult) => {
      const rows = params.rows ?? 4;
      const cols = params.cols ?? 4;
      const total = rows * cols;
      const pairCount = Math.floor(total / 2);
      const symbols = [];
      for (let i = 0; i < pairCount; i++) symbols.push(i, i);
      // shuffle
      for (let i = symbols.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [symbols[i], symbols[j]] = [symbols[j], symbols[i]];
      }

      let revealed = [];
      let matched = new Set();
      let moves = 0;
      let lock = false;

      canvas.onclick = e => {
        if (lock) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        const cellW = canvas.width / cols;
        const cellH = canvas.height / rows;
        const c = Math.floor(x / cellW);
        const r = Math.floor(y / cellH);
        const idx = r * cols + c;
        if (idx < 0 || idx >= symbols.length) return;
        if (matched.has(idx) || revealed.includes(idx)) return;

        revealed.push(idx);
        if (revealed.length === 2) {
          moves++;
          const [a, b] = revealed;
          if (symbols[a] === symbols[b]) {
            matched.add(a);
            matched.add(b);
            revealed = [];
            if (matched.size === total) {
              const score = Math.max(1, (pairCount * 10) - moves * 2);
              onResult({ score, label: `${moves} moves`, outcome: "win" });
            }
          } else {
            lock = true;
            setTimeout(() => {
              revealed = [];
              lock = false;
            }, 650);
          }
        }
      };

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.fillStyle = "#050617";
        ctx.fillRect(0, 0, w, h);

        const cellW = w / cols;
        const cellH = h / rows;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = Math.min(cellW, cellH) * 0.45 + "px system-ui";

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const idx = r * cols + c;
            const x = c * cellW;
            const y = r * cellH;
            const isMatched = matched.has(idx);
            const isRevealed = revealed.includes(idx);
            let color;
            if (isMatched) color = "#1cc98e";
            else if (isRevealed) color = "#4ef0ff";
            else color = "#151633";

            ctx.fillStyle = color;
            ctx.fillRect(
              x + 4,
              y + 4,
              cellW - 8,
              cellH - 8
            );

            if (isRevealed || isMatched) {
              ctx.fillStyle = "#050617";
              ctx.fillText(
                symbols[idx],
                x + cellW / 2,
                y + cellH / 2
              );
            }
          }
        }

        ctx.fillStyle = "#9aa0d2";
        ctx.font = "12px system-ui";
        ctx.textAlign = "left";
        ctx.fillText("Moves: " + moves, 10, 18);
      }

      return { update() {}, render, cleanup() { canvas.onclick = null; } };
    };

    // --- 5: Simon‑style sequence ---
    variantInitializers["simon"] = (params, onResult) => {
      const pads = params.pads ?? 4;
      const fast = !!params.fast;
      const colors = ["#ff5e7a", "#4ef0ff", "#ffc857", "#4ef09e"];
      let sequence = [];
      let userIndex = 0;
      let showing = true;
      let showIndex = 0;
      let showTimer = 0;
      let flashPad = -1;
      let score = 0;

      function addStep() {
        sequence.push(Math.floor(Math.random() * pads));
        userIndex = 0;
        showing = true;
        showIndex = 0;
        showTimer = 0;
      }

      addStep();

      canvas.onclick = e => {
        if (showing) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const dx = x - cx;
        const dy = y - cy;
        const angle = Math.atan2(dy, dx); // -PI..PI
        let padIndex = 0;
        if (angle >= -Math.PI / 4 && angle < Math.PI / 4) padIndex = 0; // right
        else if (angle >= Math.PI / 4 && angle < (3 * Math.PI) / 4) padIndex = 1; // bottom
        else if (angle >= (-3 * Math.PI) / 4 && angle < -Math.PI / 4) padIndex = 3; // top
        else padIndex = 2; // left

        flashPad = padIndex;
        setTimeout(() => (flashPad = -1), 150);

        if (padIndex === sequence[userIndex]) {
          userIndex++;
          if (userIndex >= sequence.length) {
            score = sequence.length;
            addStep();
          }
        } else {
          onResult({ score, label: "Sequence length: " + score, outcome: "loss" });
          sequence = [];
          score = 0;
          addStep();
        }
      };

      function update(dt) {
        if (!showing) return;
        showTimer += dt;
        const delay = fast ? 350 : 550;
        const pause = fast ? 170 : 250;
        if (flashPad === -1 && showTimer > pause) {
          flashPad = sequence[showIndex];
          showTimer = 0;
        } else if (flashPad !== -1 && showTimer > delay) {
          flashPad = -1;
          showTimer = 0;
          showIndex++;
          if (showIndex >= sequence.length) {
            showing = false;
          }
        }
      }

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        const cx = w / 2;
        const cy = h / 2;
        const radius = Math.min(w, h) * 0.35;

        ctx.fillStyle = "#050617";
        ctx.fillRect(0, 0, w, h);

        for (let i = 0; i < pads; i++) {
          const startAngle = (i * Math.PI * 2) / pads;
          const endAngle = ((i + 1) * Math.PI * 2) / pads;
          const baseColor = colors[i % colors.length];
          const isActive = i === flashPad;
          ctx.beginPath();
          ctx.moveTo(cx, cy);
          ctx.arc(cx, cy, radius, startAngle, endAngle);
          ctx.closePath();
          ctx.fillStyle = isActive ? baseColor : "#151633";
          ctx.fill();
          ctx.strokeStyle = isActive ? "#ffffff" : "#272b4b";
          ctx.lineWidth = 2;
          ctx.stroke();
        }

        ctx.beginPath();
        ctx.arc(cx, cy, radius * 0.35, 0, Math.PI * 2);
        ctx.fillStyle = "#050617";
        ctx.fill();
        ctx.strokeStyle = "#272b4b";
        ctx.lineWidth = 3;
        ctx.stroke();

        ctx.fillStyle = "#fefefe";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = "16px system-ui";
        ctx.fillText(showing ? "Watch" : "Repeat", cx, cy);

        ctx.font = "12px system-ui";
        ctx.fillStyle = "#9aa0d2";
        ctx.fillText("Length: " + sequence.length, cx, cy + radius * 0.55);
      }

      return { update, render, cleanup() { canvas.onclick = null; } };
    };

    // --- 6: Dodger survival ---
    variantInitializers["dodger"] = (params, onResult) => {
      const speedFactor = params.speed ?? 2;
      const tiny = !!params.tinyPlayer;
      const player = {
        x: canvas.width / 2,
        y: canvas.height - 35,
        w: tiny ? 18 : 32,
        h: tiny ? 18 : 26,
        speed: 0.45
      };
      const keys = { left: false, right: false };
      const blocks = [];
      let elapsed = 0;
      let alive = true;
      let spawnTimer = 0;

      function spawnBlock() {
        const bw = 18 + Math.random() * 36;
        blocks.push({
          x: Math.random() * (canvas.width - bw),
          y: -40,
          w: bw,
          h: 10 + Math.random() * 18,
          vy: (0.12 + Math.random() * 0.12) * speedFactor
        });
      }

      function keyHandler(e, down) {
        if (e.key === "ArrowLeft") keys.left = down;
        if (e.key === "ArrowRight") keys.right = down;
      }

      window.addEventListener("keydown", e => keyHandler(e, true));
      window.addEventListener("keyup", e => keyHandler(e, false));

      function endRun() {
        alive = false;
        const score = Math.floor(elapsed / 100);
        onResult({ score, label: `${(elapsed / 1000).toFixed(1)}s survived`, outcome: "loss" });
      }

      function update(dt) {
        if (!alive) return;
        elapsed += dt;
        spawnTimer += dt;
        const spawnInterval = 700 / speedFactor;
        if (spawnTimer > spawnInterval) {
          spawnTimer = 0;
          spawnBlock();
        }

        const move = player.speed * dt * speedFactor;
        if (keys.left) player.x -= move;
        if (keys.right) player.x += move;
        if (player.x < 10) player.x = 10;
        if (player.x + player.w > canvas.width - 10) player.x = canvas.width - 10 - player.w;

        for (const b of blocks) {
          b.y += b.vy * dt;
        }

        // collision
        for (const b of blocks) {
          if (
            b.x < player.x + player.w &&
            b.x + b.w > player.x &&
            b.y < player.y + player.h &&
            b.y + b.h > player.y
          ) {
            endRun();
            break;
          }
        }

        // remove offscreen
        for (let i = blocks.length - 1; i >= 0; i--) {
          if (blocks[i].y > canvas.height + 40) blocks.splice(i, 1);
        }
      }

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.fillStyle = "#050617";
        ctx.fillRect(0, 0, w, h);

        ctx.fillStyle = "#111325";
        for (let x = 0; x < w; x += 30) {
          ctx.fillRect(x, 0, 1, h);
        }

        ctx.fillStyle = tiny ? "#4ef0ff" : "#4ef09e";
        ctx.fillRect(player.x, player.y, player.w, player.h);

        ctx.fillStyle = "#ff5e7a";
        for (const b of blocks) {
          ctx.fillRect(b.x, b.y, b.w, b.h);
        }

        ctx.fillStyle = "#9aa0d2";
        ctx.font = "12px system-ui";
        ctx.textAlign = "left";
        ctx.fillText(`Time: ${(elapsed / 1000).toFixed(1)}s`, 10, 18);
      }

      return {
        update,
        render,
        cleanup() {
          window.onkeydown = null;
          window.onkeyup = null;
        }
      };
    };

    // --- 7: Number grid (1..N²) ---
    variantInitializers["number-grid"] = (params, onResult) => {
      const size = params.size ?? 4;
      const total = size * size;
      const nums = Array.from({ length: total }, (_, i) => i + 1);
      for (let i = nums.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [nums[i], nums[j]] = [nums[j], nums[i]];
      }
      let next = 1;
      let startTime = performance.now();
      let finished = false;

      canvas.onclick = e => {
        if (finished) return;
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        const cellW = canvas.width / size;
        const cellH = canvas.height / size;
        const c = Math.floor(x / cellW);
        const r = Math.floor(y / cellH);
        const idx = r * size + c;
        if (idx < 0 || idx >= nums.length) return;
        if (nums[idx] === next) {
          next++;
          if (next > total) {
            finished = true;
            const time = performance.now() - startTime;
            const score = Math.max(1, 40000 - time);
            onResult({
              score: Math.round(score),
              label: (time / 1000).toFixed(2) + "s",
              outcome: "win"
            });
          }
        }
      };

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.fillStyle = "#050617";
        ctx.fillRect(0, 0, w, h);

        const cellW = w / size;
        const cellH = h / size;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.font = Math.min(cellW, cellH) * 0.4 + "px system-ui";

        for (let r = 0; r < size; r++) {
          for (let c = 0; c < size; c++) {
            const idx = r * size + c;
            const value = nums[idx];
            const x = c * cellW;
            const y = r * cellH;
            const isNext = value === next;
            ctx.fillStyle = isNext ? "#4ef0ff" : "#151633";
            ctx.fillRect(x + 4, y + 4, cellW - 8, cellH - 8);
            ctx.fillStyle = "#fefefe";
            ctx.fillText(value, x + cellW / 2, y + cellH / 2);
          }
        }

        ctx.fillStyle = "#9aa0d2";
        ctx.font = "12px system-ui";
        ctx.textAlign = "left";
        ctx.fillText("Next: " + next, 10, 18);
      }

      return { update() {}, render, cleanup() { canvas.onclick = null; } };
    };

    // --- 8: Typing lanes ---
    variantInitializers["typing"] = (params, onResult) => {
      const spawnRate = params.spawnRate ?? 1600;
      const words = ["flux", "nexus", "arc", "phase", "loop", "echo", "nova", "grid", "pulse", "warp"];
      const active = [];
      let timer = 0;
      let score = 0;
      let streak = 0;
      let input = "";
      let alive = true;

      function spawnWord() {
        const text = words[Math.floor(Math.random() * words.length)];
        active.push({
          text,
          x: 40 + Math.random() * (canvas.width - 80),
          y: -10,
          vy: 0.05 + Math.random() * 0.05
        });
      }

      function endRun() {
        alive = false;
        onResult({ score, label: "Score: " + score, outcome: "loss" });
      }

      window.addEventListener("keydown", e => {
        if (!alive) return;
        if (e.key.length === 1 && /^[a-zA-Z]$/.test(e.key)) {
          input += e.key.toLowerCase();
        } else if (e.key === "Backspace") {
          input = input.slice(0, -1);
        } else if (e.key === "Enter") {
          if (!input) return;
          const matchIndex = active.findIndex(w => w.text === input);
          if (matchIndex >= 0) {
            active.splice(matchIndex, 1);
            streak++;
            score += 10 * streak;
          } else {
            streak = 0;
          }
          input = "";
        }
      });

      function update(dt) {
        if (!alive) return;
        timer += dt;
        if (timer > spawnRate) {
          timer = 0;
          spawnWord();
        }
        for (const w of active) {
          w.y += w.vy * dt;
        }
        for (let i = active.length - 1; i >= 0; i--) {
          if (active[i].y > canvas.height - 20) {
            endRun();
            break;
          }
        }
      }

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.fillStyle = "#050617";
        ctx.fillRect(0, 0, w, h);

        ctx.fillStyle = "#151633";
        ctx.fillRect(0, h - 40, w, 40);

        ctx.fillStyle = "#9aa0d2";
        ctx.font = "12px system-ui";
        ctx.textAlign = "left";
        ctx.fillText("Type code & press Enter", 10, h - 24);

        ctx.fillStyle = "#ffffff";
        ctx.font = "16px system-ui";
        ctx.fillText(input || " ", 10, h - 8);

        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        ctx.font = "16px system-ui";
        for (const word of active) {
          ctx.fillStyle = "#4ef0ff";
          ctx.fillText(word.text, word.x, word.y);
        }

        ctx.textAlign = "left";
        ctx.textBaseline = "alphabetic";
        ctx.fillStyle = "#9aa0d2";
        ctx.font = "12px system-ui";
        ctx.fillText("Score: " + score, 10, 18);
        ctx.fillText("Streak: " + streak, 10, 34);
      }

      return {
        update,
        render,
        cleanup() {
          window.onkeydown = null;
        }
      };
    };

    // --- 9: Target clicker ---
    variantInitializers["target-click"] = (params, onResult) => {
      const lifetime = params.lifetime ?? 1100;
      const multi = !!params.multi;
      const targets = [];
      let lastSpawn = 0;
      let score = 0;
      let combo = 0;
      let misses = 0;

      function spawnTarget() {
        const r = 12 + Math.random() * 18;
        targets.push({
          x: 20 + Math.random() * (canvas.width - 40),
          y: 20 + Math.random() * (canvas.height - 40),
          r,
          born: performance.now()
        });
      }

      canvas.onclick = e => {
        const rect = canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) * (canvas.width / rect.width);
        const y = (e.clientY - rect.top) * (canvas.height / rect.height);
        let hit = -1;
        for (let i = 0; i < targets.length; i++) {
          const t = targets[i];
          const dx = x - t.x;
          const dy = y - t.y;
          if (Math.sqrt(dx * dx + dy * dy) <= t.r) {
            hit = i;
            break;
          }
        }
        if (hit >= 0) {
          targets.splice(hit, 1);
          combo++;
          score += 10 * combo;
        } else {
          misses++;
          combo = 0;
          if (misses >= 5) {
            onResult({ score, label: "Miss limit reached", outcome: "loss" });
            score = 0;
            combo = 0;
            misses = 0;
            targets.length = 0;
          }
        }
      };

      function update() {
        const now = performance.now();
        if (!multi && targets.length === 0 && now - lastSpawn > 200) {
          lastSpawn = now;
          spawnTarget();
        } else if (multi && now - lastSpawn > 450) {
          lastSpawn = now;
          if (targets.length < 5) spawnTarget();
        }

        for (let i = targets.length - 1; i >= 0; i--) {
          if (now - targets[i].born > lifetime) {
            targets.splice(i, 1);
            misses++;
            combo = 0;
            if (misses >= 5) {
              onResult({ score, label: "Too many misses", outcome: "loss" });
              score = 0;
              combo = 0;
              misses = 0;
              targets.length = 0;
            }
          }
        }
      }

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.fillStyle = "#050617";
        ctx.fillRect(0, 0, w, h);

        const now = performance.now();
        for (const t of targets) {
          const age = now - t.born;
          const p = 1 - Math.min(1, age / lifetime);
          const outer = t.r * (1 + (1 - p) * 0.5);
          ctx.beginPath();
          ctx.arc(t.x, t.y, outer, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(78,240,255,0.12)";
          ctx.fill();
          ctx.beginPath();
          ctx.arc(t.x, t.y, t.r, 0, Math.PI * 2);
          ctx.fillStyle = "#4ef0ff";
          ctx.fill();
          ctx.beginPath();
          ctx.arc(t.x, t.y, t.r * 0.4, 0, Math.PI * 2);
          ctx.fillStyle = "#050617";
          ctx.fill();
        }

        ctx.fillStyle = "#9aa0d2";
        ctx.font = "12px system-ui";
        ctx.textAlign = "left";
        ctx.fillText("Score: " + score, 10, 18);
        ctx.fillText("Combo: " + combo, 10, 34);
        ctx.fillText("Misses: " + misses + " / 5", 10, 50);
      }

      return { update, render, cleanup() { canvas.onclick = null; } };
    };

    // --- 10: Snake ---
    variantInitializers["snake"] = (params, onResult) => {
      const speed = params.speed ?? 130;
      const walls = !!params.walls;
      const cellSize = 15;
      const cols = Math.floor(canvas.width / cellSize);
      const rows = Math.floor(canvas.height / cellSize);

      let dir = { x: 1, y: 0 };
      let nextDir = { x: 1, y: 0 };
      let snake = [{ x: Math.floor(cols / 2), y: Math.floor(rows / 2) }];
      let food = {
        x: Math.floor(Math.random() * cols),
        y: Math.floor(Math.random() * rows)
      };
      let elapsed = 0;
      let score = 0;
      let alive = true;

      function placeFood() {
        let pos;
        do {
          pos = {
            x: Math.floor(Math.random() * cols),
            y: Math.floor(Math.random() * rows)
          };
        } while (snake.some(s => s.x === pos.x && s.y === pos.y));
        food = pos;
      }

      window.addEventListener("keydown", e => {
        if (e.key === "ArrowUp" && dir.y === 0) nextDir = { x: 0, y: -1 };
        if (e.key === "ArrowDown" && dir.y === 0) nextDir = { x: 0, y: 1 };
        if (e.key === "ArrowLeft" && dir.x === 0) nextDir = { x: -1, y: 0 };
        if (e.key === "ArrowRight" && dir.x === 0) nextDir = { x: 1, y: 0 };
      });

      function tick() {
        if (!alive) return;
        dir = nextDir;
        const head = snake[0];
        let nx = head.x + dir.x;
        let ny = head.y + dir.y;

        if (walls) {
          if (nx < 0 || nx >= cols || ny < 0 || ny >= rows) {
            alive = false;
            onResult({ score, label: "Crashed into wall", outcome: "loss" });
            return;
          }
        } else {
          if (nx < 0) nx = cols - 1;
          if (nx >= cols) nx = 0;
          if (ny < 0) ny = rows - 1;
          if (ny >= rows) ny = 0;
        }

        if (snake.some(s => s.x === nx && s.y === ny)) {
          alive = false;
          onResult({ score, label: "Bit yourself", outcome: "loss" });
          return;
        }
        snake.unshift({ x: nx, y: ny });
        if (nx === food.x && ny === food.y) {
          score += 10;
          placeFood();
        } else {
          snake.pop();
        }
      }

      function update(dt) {
        elapsed += dt;
        if (elapsed > speed) {
          elapsed = 0;
          tick();
        }
      }

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.fillStyle = "#050617";
        ctx.fillRect(0, 0, w, h);

        ctx.fillStyle = "#111325";
        ctx.fillRect(food.x * cellSize, food.y * cellSize, cellSize, cellSize);

        ctx.fillStyle = "#4ef09e";
        for (const s of snake) {
          ctx.fillRect(s.x * cellSize, s.y * cellSize, cellSize - 1, cellSize - 1);
        }

        if (walls) {
          ctx.strokeStyle = "#ff5e7a";
          ctx.lineWidth = 2;
          ctx.strokeRect(1, 1, cols * cellSize - 2, rows * cellSize - 2);
        }

        ctx.fillStyle = "#9aa0d2";
        ctx.font = "12px system-ui";
        ctx.textAlign = "left";
        ctx.fillText("Score: " + score, 10, 18);
      }

      return {
        update,
        render,
        cleanup() {
          window.onkeydown = null;
        }
      };
    };

    // --- 11: Maze ---
    variantInitializers["maze"] = (params, onResult) => {
      const size = params.size ?? 9;
      const grid = Array.from({ length: size }, () =>
        Array.from({ length: size }, () => 1)
      );

      // Simple random carving (not perfect maze but playful)
      function carve(x, y) {
        const dirs = [
          [1, 0],
          [-1, 0],
          [0, 1],
          [0, -1]
        ].sort(() => Math.random() - 0.5);
        grid[y][x] = 0;
        for (const [dx, dy] of dirs) {
          const nx = x + dx * 2;
          const ny = y + dy * 2;
          if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && grid[ny][nx] === 1) {
            grid[y + dy][x + dx] = 0;
            carve(nx, ny);
          }
        }
      }
      carve(1, 1);

      const start = { x: 1, y: 1 };
      const goal = { x: size - 2, y: size - 2 };
      let player = { ...start };
      let pulses = 0;
      let pulseTimer = 0;

      const pulsingWalls = [];
      for (let y = 1; y < size - 1; y++) {
        for (let x = 1; x < size - 1; x++) {
          if (grid[y][x] === 1 && Math.random() < 0.18) {
            pulsingWalls.push({ x, y });
          }
        }
      }

      window.addEventListener("keydown", e => {
        const d = { x: 0, y: 0 };
        if (e.key === "ArrowUp") d.y = -1;
        if (e.key === "ArrowDown") d.y = 1;
        if (e.key === "ArrowLeft") d.x = -1;
        if (e.key === "ArrowRight") d.x = 1;
        if (d.x === 0 && d.y === 0) return;
        const nx = player.x + d.x;
        const ny = player.y + d.y;
        if (nx < 0 || nx >= size || ny < 0 || ny >= size) return;
        // Check pulsing wall state
        const isPulsing = pulsingWalls.some(w => w.x === nx && w.y === ny);
        const phase = (pulses % 2) === 1; // when true, pulsing walls are open
        if (grid[ny][nx] === 0 || (isPulsing && phase)) {
          player = { x: nx, y: ny };
        }
        if (player.x === goal.x && player.y === goal.y) {
          const score = Math.max(1, 300 - pulses * 2);
          onResult({ score, label: `Pulses: ${pulses}`, outcome: "win" });
          player = { ...start };
          pulses = 0;
        }
      });

      function update(dt) {
        pulseTimer += dt;
        if (pulseTimer > 900) {
          pulseTimer = 0;
          pulses++;
        }
      }

      function render() {
        const w = canvas.width;
        const h = canvas.height;
        ctx.fillStyle = "#050617";
        ctx.fillRect(0, 0, w, h);

        const cellW = w / size;
        const cellH = h / size;

        const phase = (pulses % 2) === 1;

        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const isPulsing = pulsingWalls.some(w => w.x === x && w.y === y);
            if (grid[y][x] === 1) {
              if (isPulsing) {
                ctx.fillStyle = phase ? "#151633" : "#ff5e7a";
              } else {
                ctx.fillStyle = "#151633";
              }
              ctx.fillRect(
                x * cellW + 2,
                y * cellH + 2,
                cellW - 4,
                cellH - 4
              );
            }
          }
        }

        // goal
        ctx.fillStyle = "#4ef09e";
        ctx.fillRect(
          goal.x * cellW + 4,
          goal.y * cellH + 4,
          cellW - 8,
          cellH - 8
        );

        // player
        ctx.fillStyle = "#4ef0ff";
        ctx.beginPath();
        ctx.arc(
          player.x * cellW + cellW / 2,
          player.y * cellH + cellH / 2,
          Math.min(cellW, cellH) * 0.3,
          0,
          Math.PI * 2
        );
        ctx.fill();

        ctx.fillStyle = "#9aa0d2";
        ctx.font = "12px system-ui";
        ctx.textAlign = "left";
        ctx.fillText("Pulses: " + pulses, 10, 18);
        ctx.fillText("Phase: " + (phase ? "Open" : "Closed"), 10, 34);
      }

      return {
        update,
        render,
        cleanup() {
          window.onkeydown = null;
        }
      };
    };
  </script>
</body>
</html>
